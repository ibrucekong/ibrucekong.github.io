[{"title":"ArcGIS API for JavaScript 4.2学习笔记[12] View的弹窗（Popup）","url":"/posts/3310621046/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6399628.html**\n\n-----\n\n看本文前最好对第二章（Mapping and Views）中的Map和View类有理解。\n\n视图类有一个属性是Popup类型的popup，查阅API知道这个就是视图的弹窗，每一个View的实例都有一个popup。\n\n这个popup属性在View对象实例化的时候就实例化了的，即随着View的出生，它也会出生，它拥有默认的样子，它显示的文字也是默认的样式。\n\n我们看看Popup这个类：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170214235644847-159453514.png)\n\n直接继承自Accessor，位于widgets模块下，说明Popup（弹窗）也是小部件的一种。但是为什么要单独拿出来讲呢？可能用法上比较复杂吧。\n\n如果用户对弹窗有更高的样式要求，官方的说法是\n\n可以自己new一个Popup对象，替换掉view默认的popup即可。\n\n其实Popup有个兄弟类，叫PopupTemplate，它长得很像Popup，但是在功能上更服务于Layer和Graphic，即地理数据，而且也是高度可自定义的，在下一节会细说这两个的区别。\n\n说完了Popup这个新玩意儿，我就来说说第一个例子吧！\n\n它的功能就是点击View上的一个地方，就会弹出一个小窗，显示经纬度和其他信息。\n\n------\n\n引用\n\n直接给：\n\n```javascript\nrequire(\n    [\n      \"esri/tasks/Locator\",\n      \"esri/Map\",\n      \"esri/views/MapView\",\n      \"dojo/domReady!\"\n    ], \n    function(){}\n);\n```\n\n函数参数中因为Map和View 对象是经常性出现的，所以就用 var map = new Map(...);代替了（以后也是）\n\n所以函数参数的关键代码是：\n\n```\nfunction(Locator, Map, MapView){\n        var map = new Map(...);\n        var view = new MapView(...);\n        var locatorTask = new Locator({\n            url : \"https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer\";\n　　　　 });\n        view.on(\"click\", funcion(event){...})\n}\n```\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\nlocatorTask是一个Locator类的对象，用于定位服务。这个不用知道太详细，因为本例中重点并不是它。\n\n重点应该是view的事件“click”，写法同上，但是事件的方法体没有写完整。\n\n我们就来看看这个事件的方法体具体是什么：\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```javascript\nfunction(event){\n        //获取经纬度\n        var lat = Math.round(event.mapPoint.latitude * 1000) / 1000;\n        var lon = Math.round(event.mapPoint.longitude * 1000) / 1000;\n        view.popup.open({\n            title: \"Reverse geocode: [\" + lon + \", \" + lat + \"]\",\n            location: event.mapPoint\n        });\n\n        //定位服务，可以省略，不是本例中的主要内容\n        locatorTask.locationToAddress(event.mapPoint)\n        .then(function(response) {\n          var address = response.address.Match_addr;\n          view.popup.content = address;\n        })\n        .otherwise(function(err) {\n          view.popup.content =\n            \"No address was found for this location\";\n        });\n}\n```\n\n我们看到了，从click事件的event参数中获取到了lat和lon，即经纬度，用Math.round方法对数字进行了一定的处理。\n\n然后关键的一句：\n\nview.popup.open({...});\n\n我们先不说这个是什么，但是肯定是一个方法。\n\n下面的then()方法，是Locator对象的locationToAddress方法的Promise返回对象的回调，用于获取地址成功后把地址显示到popup上。\n\n关键的一句：\n\nview.popup.content = address;\n\n在下面otherwise()方法也有类似的。\n\n现在，我们转到Popup这个类的定义。\n\n> Popup类\n>\n> 继承自Accessor类\n>\n> 主要属性：actions（Collection类型）、content（String或Node类型）、location（Point类型）、title（String类型）...\n>\n> 主要方法：open()、destroy()...\n\n看得出，上面的代码使用了open方法，content属性、location属性、title属性。\n\nopen方法会把popup的visible属性改为true，然后显示到指定的位置：location。\n\n是不是很简单呢？\n\n更深一层的理解，既然能open，那么肯定是有这个实例的，更说明了popup这个属性是一个对象，在View实例化的时候就完成了实例化。\n\n对其content、title属性进行设置就可以在弹出窗中看到想要的内容和标题了。\n\n------\n\n \n\n总结一下。\n\n1. View对象自带Popup实例，并随着View对象实例化而实例化。\n\n2. Popup使用open()方法显示出来，接受location、title、content等可选参数以指定内容、弹窗点等。\n\n最后给个图：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170215113704316-1722350220.png)\n\n很显而易见。\n\n给出官方的源代码（没有删除注释）\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1,user-scalable=no\">\n  <title>Get started with popups - 4.2</title>\n\n  <style>\n    html,\n    body,\n    #viewDiv {\n      padding: 0;\n      margin: 0;\n      height: 100%;\n      width: 100%;\n    }\n    \n    #instruction {\n      z-index: 99;\n      position: absolute;\n      top: 15px;\n      left: 50%;\n      padding: 5px;\n      margin-left: -175px;\n      height: 20px;\n      width: 350px;\n      background: rgba(25, 25, 25, 0.8);\n      color: white;\n    }\n  </style>\n\n  <link rel=\"stylesheet\" href=\"https://js.arcgis.com/4.2/esri/css/main.css\">\n  <script src=\"https://js.arcgis.com/4.2/\"></script>\n\n  <script>\n    require([\n      \"esri/tasks/Locator\",\n      \"esri/Map\",\n      \"esri/views/MapView\",\n      \"dojo/domReady!\"\n    ], function(\n      Locator,\n      Map,\n      MapView\n    ) {\n\n      // Set up a locator task using the world geocoding service\n      var locatorTask = new Locator({\n        url: \"https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer\"\n      });\n\n      // Create the Map\n      var map = new Map({\n        basemap: \"streets-navigation-vector\"\n      });\n\n      // Create the MapView\n      var view = new MapView({\n        container: \"viewDiv\",\n        map: map,\n        center: [-116.3031, 43.6088],\n        zoom: 12\n      });\n\n      /*******************************************************************\n       * This click event sets generic content on the popup not tied to\n       * a layer, graphic, or popupTemplate. The location of the point is\n       * used as input to a reverse geocode method and the resulting\n       * address is printed to the popup content.\n       *******************************************************************/\n      view.on(\"click\", function(event) {\n        // Get the coordinates of the click on the view\n        var lat = Math.round(event.mapPoint.latitude * 1000) / 1000;\n        var lon = Math.round(event.mapPoint.longitude * 1000) / 1000;\n\n        view.popup.open({\n          // Set the popup's title to the coordinates of the location\n          title: \"Reverse geocode: [\" + lon + \", \" + lat + \"]\",\n          location: event.mapPoint // Set the location of the popup to the clicked location\n        });\n\n        // Display the popup\n        // Execute a reverse geocode using the clicked location\n        locatorTask.locationToAddress(event.mapPoint).then(function(\n          response) {\n          // If an address is successfully found, print it to the popup's content\n          var address = response.address.Match_addr;\n          view.popup.content = address;\n        }).otherwise(function(err) {\n          // If the promise fails and no result is found, print a generic message\n          // to the popup's content\n          view.popup.content =\n            \"No address was found for this location\";\n        });\n      });\n    });\n  </script>\n</head>\n\n<body>\n  <div id=\"viewDiv\"></div>\n  <div id=\"instruction\">Click any location on the map to see its street address</div>\n</body>\n\n</html>\n```\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[11] 官方第五章Popups（弹窗）概览与解释","url":"/posts/2760278425/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6399346.html**\n\n------\n\n直接跳过第三第四章了，第三章Layer和第四章可视化，怎么说呢，Layer是组织数据的，是Map的属性之一。可视化属于符号化编程，暂时不看。\n\n第五章是对数据、结果的显示，类似于alert()、.NET的MessageBox，弹窗嘛。\n\n官方的解释很清楚了，我翻译过来，再加上自己的一些理解。\n\nPopup，是Accessor的 一个子类，它的实例是弹窗对象。像这样\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170214212651254-336683179.png)\n\n是不是很熟悉？对，在老版本的百度地图中，也有很多这种弹窗的例子。\n\n这一章比较短，给出预览：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170214213321754-740696313.png)\n\n------\n\n \n\n【Get started with popups】\n\n【Get started with PopupTemplate】\n\n前两节是预热，通过例子告诉用户怎么使用 Popup 和 PopupTemplate 这两个直接继承自Accessor的类，去弹出一个窗口，以及简单介绍如何使用这两个类的属性。\n\nPopup作用于View对象，而PopupTemplate作用于一些Layer对象或者Graphic对象。\n\n【Popup dock positions】\n\n这节从名字就知道了，控制弹窗的位置。\n\n【Multiple popup elements】\n\n 使用多个弹窗元素。弹窗里可以放置很多种元素，因为弹窗不可能只有文本，还可以有图表、外链等。\n\n 还介绍了怎么使用related table（并不知道是什么，等看到源代码就知道怎么回事了吧？）\n\n【PopupTemplate with functions】\n\n PopupTemplate这个类的实例，和functions？\n\n 口语点的解释就是：\n\n 在Layer或者Graphic的弹出窗（PopupTemplate）中，如果对输出文本（输出信息）有特殊的格式需求，是可以指定一段代码来完成这个格式化过程的。\n\n 官方的例子，拿人口变化比率来说明。人口变化这个比率（如下图）\n\n ![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170214230626894-50661014.png)\n\n 有一个图案，就是红色的向下箭头和红色的数字（如果是增长的就是绿色向上箭头和绿色数字）。\n\n 这个就不是官方的格式字符串方法了，所以就要自定义方法去完成这个信息的格式化。\n\n【Popup actions】\n\n 给弹出窗添加一些自定义的动作——看到初始弹出窗下面那个放大镜按钮没？这就是说，允许自定义按钮并添加一些功能。\n\n【Custom popup actions per feature】\n\n ![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170214220723722-428140646.png)\n\n这个看图就好解释了，字面义就是每个要素（feature）都可以定制功能，图中那个啤酒按钮就可以弹出这个地址的网站（大概）。\n\n重点应该不是这个啤酒按钮的功能了，而是能对feature的定制。这个feature的弹窗和View的弹窗有什么不同呢？到代码里看看吧。\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[10] 2D添加指北针widget、视图保存、视图padding（第二章完结）","url":"/posts/2160033807/","content":"**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6391517.html**\n\n------\n\n这几个例子是第二章除了入门之外比较简单的几个，就做个合集，把最核心的代码（第二参数）和 引用放上来即可，不作多解释。\n\n2D地图添加指北针widget\n\n2D地图一般修正方向为正北方就需要这个widget。\n\n引用：\n\n```javascript\n[\n        \"esri/Map\",\n        \"esri/views/MapView\",\n        \"esri/widgets/Compass\",\n        \"dojo/domReady!\"\n]\n```\n\n在function(Map,MapView,Compass)实例化Map和MapView后，添加这两行代码：\n\n```javascript\nvar compassWidget = new Compass({view: view});\nview.ui.add(compassWidget, \"top-left\");\n```\n\n即可。有关Compass这个widget的构造函数，可以查阅API了解更多，我感觉不会那么少吧...还有这个ui.add()方法，感觉日后添加widget布局的时候可以仔细学学。\n\nps：Compass在SceneView中是默认显示的。\n\n视图padding改变\n\n这个几乎没有难度。\n\n给个图预览吧：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170213051054832-1769929522.png)\n\n本来小岛这种东西就应该在地图的最中央位置，但是由于右边多了一块DIV（宽度320px），所以地图为了避开DIV而对齐就必须把视图的padding值改为320（和DIV一样）。在百度地图旧版本中，就喜欢搞一个面板，用于提供搜索信息的输入框和结果框、筛选按钮等。\n\n直接给出源代码：\n\n```javascript\nrequire(\n    [ \"esri/Map\", \"esri/views/MapView\", \"dojo/domReady!\" ], \n    function(Map,MapView) {\n      var map = new Map({\n        basemap: \"topo\"\n      });\n      var view = new MapView({\n        container: \"viewDiv\",\n        map: map,\n        center: [-74.045459, 40.690083], \n        zoom: 16,\n        padding: {\n          right: 320 \n        }\n      });\n    });\n```\n\n仅仅是在view的实例化中把padding的right改为320，在html中：\n\n```javascript\n<body>\n  <div id=\"viewDiv\">\n    <div id=\"sidebar\">\n      <div id=\"text\">\n            内容云云，此处省略\n      </div>\n    </div>\n  </div>\n</body>\n```\n\n在style标签中，把sidebar这个div的width设置成了同样的320px。\n\n视图保存\n\n这个就比较有趣了。首先要提供一个输入title的地方，还要有一个保存image的地方。\n\n这个例子，使用了SceneView，SceneView的map属性使用了服务器上的WebScene（专题三维地图）。由于这个比较容易，就忽略了。\n\n```javascript\n<body>\n  <div id=\"viewDiv\"></div>\n  <div id=\"createSlideDiv\">\n    New slide: <input type=\"text\" id=\"createSlideTitleInput\" size=\"10\" />\n    <button\n      id=\"createSlideButton\">Create</button>\n  </div>\n  <div id=\"slidesDiv\"></div>\n</body>\n```\n\n从html代码可以看出，提供了一个createSlideDiv，内含input和一个button以供输入。\n\n还有一个slidesDiv以供保存img列表。\n\n见下图：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170213044625879-907335029.png)\n\n第一步，把这几个div加入到view对象的ui中去。\n\n```\nview.ui.add([\"createSlideDiv\", \"slidesDiv\"], \"top-right\");\n```\n\n第二步，在view创建好后，执行以下代码。关于then()，请查看鹰眼一文的末尾。\n\n```javascript\n      view.then(function() {\n        dom.byId(\"slidesDiv\").style.visibility = \"visible\";\n        var slides = scene.presentation.slides;\n        slides.forEach(createSlideUI);\n\n        on(dom.byId(\"createSlideButton\"), \"click\", function() {\n          Slide.createFrom(view).then(function(slide) {\n            slide.title.text = dom.byId(\"createSlideTitleInput\")\n              .value;\n            scene.presentation.slides.add(slide);\n            createSlideUI(slide, \"first\");\n          });\n        });\n      });\n```\n\n首先，将slidesDiv置为可视。\n\n第二，若WebScene存在slide，那么就全部装到列表中去。\n\n然后var一个slides变量，获取WebScene实例scene的当前所有的slides。\n\n然后遍历每一个slides成员，对其进行createSlideUI操作（见下，即创建DIV列表里的UI对象）。\n\n第三，调用dojo的on(DOM元素，事件类型，事件方法体)，为新增slide的那个按钮添加click事件。\n\n注意Slide.createFrom()方法，它将从view中创建slide。\n\n在这个方法的回调函数中，设置输入框的文本slide的标题。\n\n然后把slide添加到scene这个WebScene中去。\n\n最后调用createSlideUI创建div即可。\n\n```javascript\n      function createSlideUI(slide, placement) {\n        var slideElement = domConstruct.create(\"div\", {\n          id: slide.id,\n          className: \"slide\"\n        });\n        var position = placement ? placement : \"last\";\n        domConstruct.place(slideElement, \"slidesDiv\", position);\n        domConstruct.create(\"div\", {\n          textContent: slide.title.text,\n          className: \"title\"\n        }, slideElement);\n        domConstruct.create(\"img\", {\n          src: slide.thumbnail.url,\n          title: slide.title.text\n        }, slideElement);\n        on(slideElement, \"click\", function() {\n          query(\".slide\").removeClass(\"active\");\n          domClass.add(slideElement, \"active\");\n          slide.applyTo(view);\n        });\n      }\n```\n\ncreateSlideUI()方法就是创建DIV了，首先用domConstruct.create()方法创建一个divDOM元素，然后确定位置position，\n\n紧接着在这个div里添加标题div、图片div，最后为这个div添加click事件。\n\n虽然最后一个例子看起来比较长，但是逻辑都很清晰，代码也没什么碎片化，完全可以直接照抄两个代码段。\n\n------\n\n \n\n至此，第二章的学习就差不多了，关于WebScene、WebMap这两个从Map类中派生出来的子类（和Basemap同级），我觉得查阅API更有效果，而且可能是得配合ArcServer才能弄懂的东西，就先不学了。\n\n要说数据准备这块这一章还真没写，所以极有可能在Layers那章才会学到了吧，再不济，百度啊谷歌啊干什么用的？\n\n所以，整理一下所学，开始准备学习Popups（弹出框）、Searching（空间查询）和Analysis（空间分析）吧~\n\nLayers和Widgets两章留给三月份研读。\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[9] 同一种视图不同数据（Map）同步","url":"/posts/3849267338/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6391513.html**\n\n------\n\n本例子核心：对MapView对象的map属性值进行替换即可达到更改地图数据的效果。\n\n------\n\n \n\n这个例子用的不是Map对象了，而是用的发布在服务器上的专题地图（WebMap）来加载到MapView上进行显示。\n\n在html标签中，使用了section标签，不过没什么稀奇的，就把仨按钮放一块而已。\n\n先给出预览图\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170213034630800-895613805.png)\n\n三张专题地图：失踪人口密度分布、难民迁徙路线、2015年欧洲来港者。\n\n这个东西很有用，尤其是在展示同一地区的专题地图的时候，这里也展示了什么叫View，什么叫Map。\n\n因为中心点、比例尺是由View对象管控的，所以改变WebMap这个数据的时候，并不会改变位置和比例尺。\n\n我们来看代码：\n\n给出引用\n\n```javascript\n[\n      \"esri/views/MapView\",\n      \"esri/WebMap\",\n      \"dojo/on\",\n      \"dojo/domReady!\"\n]\n```\n\n很清爽。\n\n既然要用到3个专题地图，那么就创建3个WebMap对象：\n\n```javascript\nfunction(MapView, WebMap, on) {\n\n      var webmapids = [\n        \"ad5759bf407c4554b748356ebe1886e5\",\n        \"71ba2a96c368452bb73d54eadbd59faa\",\n        \"45ded9b3e0e145139cc433b503a8f5ab\"\n      ];\n      // 匿名函数返回一个WebMap实例\n      var webmaps = webmapids.map(function(webmapid) {\n        return new WebMap({\n          portalItem: {\n            id: webmapid\n          }\n        });\n      });\n      var view = new MapView({\n        map: webmaps[0],\n        container: \"viewDiv\"\n      });\n}\n```\n\n也是很简单。\n\n给定一个webmap的ID字符串数组，每个ID是WebMap的唯一标识符。\n\n然后用Collection对象的map()方法进行遍历操作，对传入的每一个ID，匿名函数返回一个WebMap实例。\n\n如何实例化WebMap，请参考API中WebMap的构造函数。\n\n然后，实例化一个MapView，map属性给定webmaps数组的第一个元素，即第一个WebMap——失踪人口图。\n\n在实例化MapView后，就是给顶头的3个按钮添加事件了。\n\ndojo给DOM元素添加事件还记得吗？就是goTo()动画那篇文章。\n\n基本语法：\n\n> on(DOM元素,事件类型,事件方法体);\n\n见下：\n\n```javascript\n      on(document.querySelector(\".btns\"), \n           \".btn-switch:click\", \n           function(event) {\n               var id = event.target.getAttribute(\"data-id\");\n               if (id) {\n                  var webmap = webmaps[id];\n                  view.map = webmap;\n                  var nodes = document.querySelectorAll(\".btn-switch\");\n                  for (var idx = 0; idx < nodes.length; idx++) {\n                       var node = nodes[idx];\n                       var mapIndex = node.getAttribute(\"data-id\");\n                       if (mapIndex === id) {\n                            node.classList.add(\"active-map\");\n                       }\n                       else {\n                           node.classList.remove(\"active-map\");\n                       }\n                 }\n            }\n      });\n```\n\n使用css选择器点选，即对类进行选择。btns被选中。\n\n在方法体内，先获取data-id这个自定义属性，进入if判断。\n\n先按data-id选择到序号一致的WebMap，假如data-id=“2”，则选中第三张WebMap。\n\n然后更改view.map属性为选择到的WebMap。\n\n这里，数据就替换完成了。\n\n从var nodes...到for循环体结束，讲的是：\n\n获取全部class为btn-switch的DOM元素。\n\n对这个数组进行遍历操作，若当前点击的div的data-id和遍历到的data-id三等号相同，那么就往这个DOM元素的classList添加active-map。\n\n若不，则移除active-map。\n\n意思就是说，如果点击的div就是当前地图，那么就标记为当前活动的WebMap，否则就不是活动的WebMap。\n\n————————\n\n整个程序就是这么简单，替换MapView对象的map属性值，修改DOM元素的classList和操作DOM元素而已。\n\n给出官方源代码：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1,user-scalable=no\">\n  <title>Load a basic WebMap and swap with another on the same View - 4.2</title>\n\n  <style>\n    html,\n    body {\n      font-family: sans-serif;\n      padding: 0;\n      margin: 0;\n      height: 100%;\n      width: 100%;\n      overflow: hidden;\n    }\n    \n    #viewDiv {\n      position: absolute;\n      right: 0;\n      left: 0;\n      top: 60px;\n      bottom: 0;\n    }\n    \n    .header {\n      position: absolute;\n      top: 0;\n      width: 100%;\n      height: 10%;\n    }\n    \n    .btns {\n      margin: 0 auto;\n      display: flex;\n      flex-direction: row;\n      justify-content: center;\n      align-items: center;\n      overflow: auto;\n    }\n    \n    .btn-switch {\n      flex-grow: 4;\n      background-color: rgba(34, 111, 14, 0.5);\n      color: #FFF;\n      margin: 1px;\n      width: 50%;\n      padding: 20px;\n      overflow: auto;\n      text-align: center;\n      cursor: pointer;\n      font-size: 0.7em;\n    }\n    \n    .active-map {\n      color: #fff;\n      background-color: rgba(34, 111, 14, 1);\n    }\n  </style>\n\n  <link rel=\"stylesheet\" href=\"https://js.arcgis.com/4.2/esri/css/main.css\">\n  <script src=\"https://js.arcgis.com/4.2/\"></script>\n\n  <script>\n    require([\n      \"esri/views/MapView\",\n      \"esri/WebMap\",\n      \"dojo/on\",\n      \"dojo/domReady!\"\n    ], function(\n      MapView, WebMap,\n      on\n    ) {\n\n      var webmapids = [\n        \"ad5759bf407c4554b748356ebe1886e5\",\n        \"71ba2a96c368452bb73d54eadbd59faa\",\n        \"45ded9b3e0e145139cc433b503a8f5ab\"\n      ];\n\n      /************************************************************\n       * Create multiple WebMap instances\n       ************************************************************/\n      var webmaps = webmapids.map(function(webmapid) {\n        return new WebMap({\n          portalItem: {\n            id: webmapid\n          }\n        });\n      });\n\n      /************************************************************\n       * Initialize the View with the first WebMap\n       ************************************************************/\n      var view = new MapView({\n        map: webmaps[0],\n        container: \"viewDiv\"\n      });\n      on(document.querySelector(\".btns\"), \".btn-switch:click\", function(\n        event) {\n        /************************************************************\n         * On a button click, change the map of the View\n         ************************************************************/\n        var id = event.target.getAttribute(\"data-id\");\n        if (id) {\n          var webmap = webmaps[id];\n          view.map = webmap;\n          var nodes = document.querySelectorAll(\".btn-switch\");\n          for (var idx = 0; idx < nodes.length; idx++) {\n            var node = nodes[idx];\n            var mapIndex = node.getAttribute(\"data-id\");\n            if (mapIndex === id) {\n              node.classList.add(\"active-map\");\n            } else {\n              node.classList.remove(\"active-map\");\n            }\n          }\n        }\n      });\n    });\n  </script>\n</head>\n\n<body>\n  <section class=\"header\">\n    <div class=\"btns\">\n      <div class=\"btn-switch active-map\" data-id=\"0\">Missing Migrants</div>\n      <div class=\"btn-switch\" data-id=\"1\">Refugee Routes</div>\n      <div class=\"btn-switch\" data-id=\"2\">2015 European Sea Arrivals</div>\n    </div>\n  </section>\n  <div id=\"viewDiv\"></div>\n</body>\n\n</html>\n```\n\n \n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[8] 2D与3D视图同步","url":"/posts/1258689047/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6391509.html**\n\n------\n\n同一份数据不同视图查看可能用的比较少，因为3D视图放大很多后就和2D地图差不多了，畸变很小，用于超大范围的地图显示时有用，很多时候都是在平面地图上进行分析、查询、操作。教学需要可能会对这个有要求？\n\n本文没有深究两个比较复杂的函数，希望有朝一日能读懂吧，对于这种同一个Map对象不同视图的同步显示，建议直接copy后半截内容即可。\n\n------\n\n \n\n鹰眼功能和这个类似，不过鹰眼功能（即上一篇文章）是利用watch()和watchUtils.when()来实现的同步，这个例子又有什么不同呢？探究之。\n\n直接看结果图：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170213022338066-1544447155.png)\n\n看起来就是两个无边框的DIV，宽度各占50%。\n\n实际上操作的结果就是，在任意一个视图拖动、缩放、旋转视图，另一个也跟着变，几乎就是放大版的鹰眼，也可以说是鹰眼的另一种写法。\n\n------\n\n \n\n给出require的引用：\n\n```javascript\nrequire(\n    [\n      \"esri/Map\",\n      \"esri/views/MapView\",\n      \"esri/views/SceneView\",\n      \"esri/core/watchUtils\",\n      \"dojo/domReady!\"\n    ],\n     function(Map,MapView, SceneView,watchUtils){\n          //你的代码  \n     }\n);\n```\n\n嗯？又是watchUtils？看来和监听少不了干系了。\n\n//事实上，本例还是用watch监听和watchUtils监听完成的同步，但是代码难于理解，就没有仔细深究。\n\n看骨干部分：\n\n```javascript\nfunction(Map,MapView,SceneView,watchUtils){\n    var map = new Map({});\n    var view1 = new SceneView({});\n    var view2 = new MapView({});\n    \n    var synchronizeView = function(view, others){};\n    var synchronizeViews = function(views){};\n    synchronizeViews([view1,view2]);\n}\n```\n\n实例化一张地图，实例化两个视图，看来和上一个例子还是有区别的。\n\n对此，博主表示暂时保留原代码。\n\n因为synchronizeView长达60行，这个方法一定不普通。\n\n博主的建议是：\n\n如果需要对同一份底图的2D和3D视图进行同步观察显示，那么请直接把这两个syn方法copy过来，甚至包装成一个方法都可以，传入参数是两个view即可。\n\n> 有兴趣的同学可以查阅这个类：esri/core/Collection\n>\n> 这两个难于理解的方法体内用到了这个类和其几个方法，如map()方法、slice()方法、concat()方法。\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[7] 鹰眼（缩略图的实现及异步处理、Promise、回调函数、监听的笔记）","url":"/posts/3118632505/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6389054.html**\n\n------\n\n文前说明：关于style就是页面的css暂时不做评论，因为官方给的例子的样式实在太简单了，照抄阅读即可。\n\n这篇文章有着大量AJS 4.x版本添加的内容，如监听watch、Promise对象、回调函数、异步处理等内容，原理性的东西我会在文末解释，各位看官不用担心看不懂，我尽量用通俗的语言解释这些。\n\n惯例，如果不习惯从头看到尾，可以直接跳到后面看总结。\n\n------\n\n大家应该看过商业地图的缩略图功能吧？以度娘地图为例，在使用街景地图的时候，左下角会出现一个地点一样的2D小地图：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170211124618151-753389095.png)\n\n这个就是鹰眼功能的应用，在很多桌面软件中如Erdas、Envi，鹰眼是很常见的。\n\n//如果以下超链接日后更新了4.3或更高版本，请自行寻找4.2的sample配合本文学习~\n\n这次就解读[2D overview map in SceneView](https://developers.arcgis.com/javascript/latest/sample-code/overview-map/live/index.html)这个例子。\n\n源代码：[点我](view-source:https://developers.arcgis.com/javascript/latest/sample-code/overview-map/live/index.html)\n\n其实就是一个2D的MapView在3D的SceneView的显示而已，关键就在数据的同步，官方指出了watch()方法是关键。\n\n话不多说，先上最终效果图：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170211132205244-2055284662.png)\n\n结构大概就是，大的DIV里放SceneView，小的DIV里放MapView。\n\n小的DIV里又有一个黑色的区域来标识当前SceneView的区域。小的DIV的widgets被移除。\n\nhtml代码为：\n\n```html\n<body>\n  <div id=\"viewDiv\"></div>\n  <div id=\"overviewDiv\">\n    <div id=\"extentDiv\"></div>\n  </div>\n</body>\n```\n\n老样子，require给出引用（以前都叫第一个字符串数组参数，为了省事，以后直接叫引用了）\n\n```js\nrequire(\n    [\n      \"esri/Map\",\n      \"esri/views/SceneView\",\n      \"esri/views/MapView\",\n      \"esri/core/watchUtils\",\n      \"dojo/dom\",\n      \"dojo/promise/all\",\n      \"dojo/domReady!\"\n    ],\n    function(Map, SceneView, MapView, watchUtils, dom, all){\n        //你的代码\n    }\n);\n```\n\n重点应该是：\n\nview的watch()方法、watchUtils的when方法、view的toScreen方法、view的extent属性、view的then方法。\n\n------\n\n \n\n既然有两个view（DIV），那么肯定要有两份map（数据）。\n\n所以第二参数（以前的文章叫函数参数，之后都叫第二参数）先将map和view定义如下：\n\n```javascript\n      var mainMap = new Map({\n        basemap: \"hybrid\",\n        ground: \"world-elevation\"\n      });\n      var overviewMap = new Map({\n        basemap: \"osm\"\n      });\n      var mainView = new SceneView({\n        container: \"viewDiv\",\n        map: mainMap\n      });\n      var mapView = new MapView({\n        container: \"overviewDiv\",\n        map: overviewMap\n      });\n```\n\nmainMap、mainView是3D的，overviewMap、mapView是2D的。\n\n当然，我们看到的2D的小地图是没有放大缩小那些控件的，只需1行代码，就可以置空那些控件。\n\n```javascript\n      mapView.ui.components = [];\n```\n\n查阅API，可以知道ui属性是DefaultUI类，DefaultUI继承自UI类。components是字符串数组，若赋值为空数组则清空。相应的，DefaultUI类有remove和empty方法可以清除控件，就不细说了。\n\n为了便于操作，把当前区域的DIV“extendDiv”的DOM元素获取为变量：\n\n```javascript\nvar extentDiv = dom.byId(\"extentDiv\");\n```\n\n------\n\n \n\n以上就完成了准备部分。\n\n接下来，数据加载完成后，就要对2D的地图和3D的地图进行“同步”了，需要用到两个view的then方法。\n\n> then()方法是Promise对象的特有方法，而Promise是什么暂时无需了解，只要知道在AJS 4.x中Promise是一个很重要的东西。\n>\n> 而且，MapView和SceneView类都继承了Promise类。不仅如此，AJS 4.x中很多方法返回的都是Promise对象。\n\n先看看mainView（3D视图）的then方法看看它做了什么：\n\n```javascript\nmainView.then(function() {\n  mainView.goTo({\n    center: [7, 46],\n    scale: 200000,\n    heading: 35,\n    tilt: 60\n  },\n　{\n    animate: true,\n    duration: 100000\n  })\n});\n```\n\n\n\n很好，它接受了一个参数，类型是方法。这个匿名方法干了什么呢？这不就是上一篇文章里说的缩放动画嘛！（goTo）跳过，看mapView（2D视图）的then方法看它做了什么：\n\n```javascript\nmapView.then(function() {\n  mainView.watch(\"extent\", updateOverviewExtent);\n  mapView.watch(\"extent\", updateOverviewExtent);\n\n  watchUtils.when(mainView, \"stationary\", updateOverview);\n\n  function updateOverview() {\n    mapView.goTo({\n      center: mainView.center,\n      scale: mainView.scale * 2 * Math.max(mainView.width /\n        mapView.width,\n        mainView.height / mapView.height)\n    });\n  }\n\n  function updateOverviewExtent() {\n    var extent = mainView.extent;\n\n    var bottomLeft = mapView.toScreen(extent.xmin, extent.ymin);\n    var topRight = mapView.toScreen(extent.xmax, extent.ymax);\n\n    extentDiv.style.top = topRight.y + \"px\";\n    extentDiv.style.left = bottomLeft.x + \"px\";\n\n    extentDiv.style.height = (bottomLeft.y - topRight.y) + \"px\";\n    extentDiv.style.width = (topRight.x - bottomLeft.x) + \"px\";\n  }\n});\n```\n\n很长的样子。\n\n我慢慢解释。\n\n仍然是接受一个方法作为参数（为什么then接受的参数那么奇怪？文末会解释的）\n\n*//题外话：在javascript里头传函数/方法是很常见的，函数/方法是js的一种变量类型，在C/C++里头可以传递函数指针，在C#里头可以传递委托变量。*\n\n这个方法里有两个方法，命名为 updateOverview 和 updateOverviewExtent，我们根据这两个方法把这个then方法的代码拆开看，发现watch和watchUtils.when是跟这两个方法配对的。\n\n即：\n\n```javascript\n//两个视图都与updateOverviewExtent方法绑定\nmainView.watch(\"extent\", updateOverviewExtent);\nmapView.watch(\"extent\", updateOverviewExtent);\n\nfunction updateOverviewExtent() {\n  var extent = mainView.extent;\n\n  var bottomLeft = mapView.toScreen(extent.xmin, extent.ymin);\n  var topRight = mapView.toScreen(extent.xmax, extent.ymax);\n\n  extentDiv.style.top = topRight.y + \"px\";\n  extentDiv.style.left = bottomLeft.x + \"px\";\n\n  extentDiv.style.height = (bottomLeft.y - topRight.y) + \"px\";\n  extentDiv.style.width = (topRight.x - bottomLeft.x) + \"px\";\n}\n```\n\n查阅API，得知视图的父类Accessor就支持watch方法了。值得一提的是，为了实现监听变化，AJS4.x版本专门提供了watch方法代替了以前的旧方法。\n\nwatch的用法是：\n\n> 对象.watch(\"该需要监听的属性名\", 属性变化后需要执行的回调函数);\n>\n> 即某对象监听了它的某个属性后，这个属性一旦发生改变，就会去执行某些代码。\n\n在本例中，需要监听的是两个view对象的extent（范围）属性，一旦extent发生变化，那么updateOverviewExtent()方法就会被执行。\n\nupdateOverviewExtent()方法的大概意思就是：获取3D视图的范围->获取2D视图的对角线两个角点->更改2D视图上方的区域框的DOM元素的尺寸属性（top、left、height、width）\n\n光改变区域框是不行的，还要改变2D地图的范围。\n\n```javascript\nwatchUtils.when(mainView, \"stationary\", updateOverview);\n\nfunction updateOverview() {\n  mapView.goTo({\n    center: mainView.center,\n    scale: mainView.scale * 2 * Math.max(mainView.width /\n      mapView.width,\n      mainView.height / mapView.height)\n  });\n}\n```\n\nwatchUtils这个对象，是位于esri/core/watchUtils模块下的一个类。\n\n它代表的含义是：监听某个对象，当这个对象的某个属性是true时，执行给定的方法。\n\n查阅API得知，这个类提供了when这个静态方法，when方法的意义是：\n\n所以，在本例中，意思就是：\n\n当mainView这个3D视图对象的\"stationary\"属性是true时，刷新mapView这个2D视图对象。\n\n刷新2D视图对象主要用的是上一篇中说到的goTo()方法，本例只指定了center和scale这两个属性组成的Object匿名对象。\n\nSceneView类的stationary属性是布尔类型的，意义是当前视图是否已经静止（一般视图会由鼠标拖拽或者goTo()方法产生动态效果，一旦停止下来，stationary就会变成true）\n\n \n\n总结一下。\n\n这个例子大概思路就是：\n\n·先实例化两个map和两个view，对3D的mainView在创建完成后使用then()方法缩放到指定位置。\n\n·其中，对2D的mapView创建完成后使用then()方法，分别监听两个view的extent属性，还监听3D视图的stationary属性。\n\n·当extent属性发生变化时，2D视图上方范围框先进行变化，然后2D地图紧随变化。\n\n·当3D视图静止下来后，刷新2D视图。\n\n \n\n监听还算比较好理解，需要注意的不多，注意到watch和watchUtils.when这两个方法返回的都是WatchHandle对象。待以后研究多了监听后，再仔细看看别的监听方法。\n\n难点就在于then方法。\n\n------\n\n \n\n难点。\n\nthen()方法怎么来的？这要从ES6（全名ECMAScript 2015）的新规范Promise对象说起。ECMAScript是JavaScript的标准，JS是ES的实现。\n\nPromise是什么？这个东西说复杂也很复杂，它是：\n\n为了处理异步操作多层回调函数的写法枯燥、难以阅读维护而产生的，由CommonJS社区发起的一个新规范的类。\n\n最显著的特征是它实例化的对象都有then()和catch()方法（PromiseA+规范？好像是)\n\n在AJS中，继承了Promise的类有：\n\n全部的Layers\n\nMapView、SceneView、LayerView\n\nViewAnimation\n\n能返回Promise对象的类数不胜数。\n\n所以说，为什么要用Promise？\n\n这又要从异步操作说起了。\n\n————\n\n在AJS 4.x中，数据（Map类）和视图（View类）是分开的，3.x版本绘图渲染是Map自己完成的。\n\n由于View视图类被分离开，绘图逻辑就成了它的主要功能。当然，绘图不会很快，往往有一个过程，尤其是超大数据量的绘图的时候会有一个比较长的等待过程。\n\n所以，在JS里，较长的处理会丢给异步处理（就是同时进行好几个操作）\n\n但是但是，我们知道JS是单线程的，它是怎么处理异步处理的呢？简单说说，JS的异步处理其实是个“伪异步”，是先完成同步代码才执行异步代码的。\n\n通常，异步代码会做一些计算量比较大的事情，而同步代码则做一些不怎么耗时间的初始化工作。就是说\n\n同步代码花少量的时间去初始化一些事情，其间有n个异步任务丢给异步队列。当同步代码完成初始化后（时间短），异步代码开始按顺序执行。\n\n比如：界面的构建交给同步代码，而其间有n个后台数据交换、处理、计算的任务，就丢给异步队列去准备。当界面构造好（时间往往很短，几乎是秒速），异步代码就在后面开始执行。\n\n这先看到的界面会让体验好很多，如果异步代码（就是耗时比较大的任务）放在同步代码里执行，那么由于同步的性质，必须等待这些耗时大的任务执行完成才能继续往下走（js的特点，单线程）\n\n【在本例中】\n\n初始化view，我不知道在云端是怎么运行的（因为我用的是CDN来运行AJS程序），但是我知道view的实例化肯定是用了异步操作。\n\n即*先完成网页的加载（出现3D地球和2D地图，同步），再进行视图的渲染（山体拔高等，异步）。*\n\nsometimes，异步操作当然会有一个结果，比如异步在后面花好长时间算出个矩阵，但是同步代码已经结束了，异步任务丢过去的时候结果还没出来，怎么获取它？\n\n我们可以用一个方法去获取它。这个方法，古时候叫回调函数。\n\n在没有Promise类的时候，通常用回调函数这种办法实现（也能用事件、监听）异步是很正常的一种。\n\n但是当回调函数本身也是个异步操作的时候，就会显得晕头转向。\n\n*异步第一层，有结果要用回调函数返回给同步代码->回调函数是第二层，这个回调函数里头需要用二级回调函数返回结果给第一层->……*\n\n举个例子：\n\n> 我是领导，我现在有两件事：有个事儿要做，和喝茶。\n>\n> 这两件事不冲突，虽然这个事儿很无聊，耗时大（如文字录入）。\n>\n> 所以我把这个事儿丢给经理（异步第一层），我继续喝茶（同步）\n>\n> 异步第一层就是经理要做这个事，但是这个事情绝大部分是无聊的，最后的整理比较简单。\n>\n> 所以经理就把这个无聊的部分丢给职员（异步第二层），等待职员把这部分做完的同时，也去喝茶（同步）。\n>\n> 于是，职员的结果就是二级回调函数，职员把结果完成后，“回调”给经理。\n>\n> 经理拿着职员的结果整理好，“回调”给领导。（第二层异步完成）\n>\n> 此时领导茶已经喝完了（同步完成），而任务也完成了（第一层异步完成）。\n\n这里如果用老的写法将会非常的烦，如果用Promise的then写法就是\n\n> 领导要做事儿.then(function(){让经理去做})\n>\n> .then(function(){让职工做});\n\n链式写法，简单，容易看，也容易维护。\n\nthen里面的function就是回调函数，告诉异步任务完成后，要怎么处理异步结果的一段代码。\n\n最后看看then方法的语法：\n\n> then(function resolve, function rejected);\n\n我们一般只用前一个参数，即异步成功要怎么处理。而后一个参数是异步任务处理失败后要做什么。\n\n甚至AJS官方还给出了处理中要做什么的第三个参数...这个就不说那么多了。\n\n——\n\n大概清楚是这么个过程后，我们知道View对象是Promise对象（继承），而且有异步操作的过程。\n\n所以，mainView.then(function(){...});的意义就是\n\n当3D视图在服务器端异步操作成功后，使用goTo()缩放到指定的位置。\n\n \n\n文末，我还想说说监听，监听在AJS 3.x版本里是通过事件完成的，而AJS 4.x全新使用了watch一派写法。有关这些可以参考AJS 4.2的Guide文档。\n\n最后的最后，关于异步和回调函数部分我也是学了一天后才给出的模糊定义，希望大家能看懂吧...我也不是很能理解，官方给的多层then()是这样的：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170213015641832-1292521096.png)\n\n出处：[点我](https://developers.arcgis.com/javascript/latest/guide/working-with-promises/index.html)\n\nthen里头当然是方法，无参的。只有子一层的结果完成的时候，父一层的then才能凭借子一层的结果的回调完成异步。\n\n给一些我阅读中觉得不错的对异步、回调函数讲解的文章：\n\n> [大白话讲解Promise](http://www.cnblogs.com/lvdabao/p/es6-promise-1.html)\n>\n> [ECMAScript 6入门](http://es6.ruanyifeng.com/#docs/promise)\n>\n> [Javascript异步编程的4种方法](http://www.cnblogs.com/fliu/articles/5246113.html)\n>\n> [百度知道-JS中回调函数怎么理解](https://zhidao.baidu.com/question/1960024181274839300.html?fr=ala&word=JavaScript为什么需要回调&device=mobile&ssid=0&from=2001a&uid=0&pu=usm@0,sz@320_1003,ta@iphone_2_6.0_1_10.9&bd_page_type=1&baiduid=16B0F240A58D2AE4A6FDFB8BF05431C1&tj=zhidao_2_0_10_l1)\n>\n> [Javascript异步编程之—异步原理](http://www.cnblogs.com/chrischjh/p/4648395.html)\n>\n> [JS中的回调函数，以及ES6中通过promise处理回调](http://blog.csdn.net/liwusen/article/details/54142748)\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[6] goTo()地图动画","url":"/posts/929677808/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6388084.html**\n\n------\n\n这是个很有意思的例子，不过例子给的比较复杂，需要查很多API，我会在文章最后给出关键的类和属性解释。\n\n同样发现一个很有意思的事儿：博客园似乎有爬虫，我4号发布的blogs，5号就在百度和google搜索页面上看到了转载或者复制。\n\n这篇文章逻辑组织不太好，想知道怎么做缩放动画的可以直接拉到尾部看结论。\n\n当然，这篇代码比较多，不建议手机看。\n\n------\n\n \n\n进入正题，goTo()动画，官方的例子是在SceneView中实现的。\n\n照例，给出require的第一个字符串数组参数\n\n```javascript\nrequire(\n　　[\n　　　　\"esri/Map\",\n　　　　\"esri/views/SceneView\",\n　　　　\"dojo/query\",\n　　　　\"dojo/on\"\n　　　　\"dojo/domReady!\"\n　　]\n　　function(Map,SceneView,query,on)\n　　{\n　　　　//你的代码\n　　}\n);\n```\n\n 除了上一次熟悉的Map类和SceneView类，还多出来了query和on这俩，字面意思可以猜测是查询和事件有关。继续往下看。\n\n 为了实现动画移动摄像机，就要在html页面组织一些按钮。\n\n 于是，在html的body标签内如下组织：\n\n```html\n<body>\n  <div id=\"optionsDiv\">\n    <button id=\"default\">Default flight</button>\n    <button id=\"linearSlow\">Linear slow flight</button>\n    <button id=\"linearFast\">Linear fast flight</button>\n    <button id=\"expoIncrease\">Exponentially increasing speed flight</button>\n    <button id=\"fixedDuration\">10 seconds flight</button>\n    <button id=\"bounceBerlin\">Bounce to Berlin</button>\n  </div>\n  <div id=\"viewDiv\"></div>\n</body>\n```\n\n6个按钮，分别是：默认漫游、较慢漫游、较快漫游、渐渐加快漫游、10秒钟漫游、弹性缩放到柏林\n\n于是，在require的第二个函数参数里，就这样给这些button添加事件：\n\n```javascript\nfuntion(Map,SceneView,query,on)\n{\n    // 仍然是实例化两个对象，map和view\n    var map = new Map({\n        basemap: \"osm\"\n    });\n    var view = new SceneView({\n          container: \"viewDiv\",\n          map: map,\n          zoom: 4\n    });\n\n    on(dojo.query(\"#default\"), \"click\", function(){\n    \n    });    \n    on(dojo.query(\"#linearSlow\"), \"click\", function(){\n    \n    });   \n    on(dojo.query(\"#linearFast\"), \"click\", function(){\n    \n    });   \n    on(dojo.query(\"#expoIncrease\"), \"click\", function(){\n    \n    });   \n    on(dojo.query(\"#fixedDuration\"), \"click\", function(){\n    \n    });\n    on(dojo.query(\"#bounceBerlin\"), \"click\", function(){\n    \n    });\n)\n```\n\n仅仅是一个on(dojo.query(), , function(){})方法即可实现为DOM元素添加对应的事件。这里，指定了“click”事件。\n\n> 关于dojo.query()，参考博客自 - http://blog.csdn.net/dojotoolkit/article/details/6265337\n>\n> 这里借用了CSS的语法，dojo.query(\"#default\")，这样就能获取到元素了.\n>\n> 需要注意的是query方法获取到的是数组，如果只有一个那就是它本身。\n>\n> 单个按ID查找DOM元素的方法是dojo.byId()\n\n------\n\n \n\n我们继续。获取html中定义的按钮元素后添加了事件以及函数体后，自然就是为它添加动画效果了。\n\n我们取完整函数体看看，有什么异同。\n\n```javascript\non(dojo.query(\"#default\"), \"click\", function() {\n          view.goTo(shiftCamera(60));\n        });\n\n        on(dojo.query(\"#linearSlow\"), \"click\", function() {\n          view.goTo(shiftCamera(60),\n            {\n              speedFactor: 0.1,\n              easing: \"linear\"\n            });\n        });\n\n        on(dojo.query(\"#linearFast\"), \"click\", function() {\n          view.goTo(shiftCamera(60),\n            {\n              speedFactor: 6,\n              easing: \"linear\"\n            });\n        });\n\n        on(dojo.query(\"#expoIncrease\"), \"click\", function() {\n          view.goTo(shiftCamera(60),\n            {\n              duration: 4000,\n              easing: \"in-expo\"\n            });\n        });\n\n        on(dojo.query(\"#fixedDuration\"), \"click\", function() {\n          view.goTo(shiftCamera(30),\n          {\n            duration: 10000,\n            maxDuration: 10000 \n          });\n        });\n\n        // 自定义时间函数体\n        function customEasing(t) {\n          return 1 - Math.abs(Math.sin(-1.7 + t * 4.5 * Math.PI)) * Math.pow(\n            0.5, t * 10);\n        }\n\n        on(dojo.query(\"#bounceBerlin\"), \"click\", function() {\n          view.goTo({\n            position: {\n              x: 13.40,\n              y: 52.52,\n              z: 700000,\n              spatialReference: {\n                wkid: 4326\n              }\n            },\n            heading: 0,\n            tilt: 0\n          }, {\n            speedFactor: 0.3,\n            easing: customEasing\n          });\n        });\n```\n\n我们可以发现有很多东西是多出来的。以默认漫游按钮为切入点，发现使用了view这个对象的goTo()方法，参数未知，看来是一个有返回值的方法。查看官方API和本例代码得知goTo()方法和shiftCamera()方法的含义：\n\n> goTo()方法\n>\n> 将视图转移到给定的目标。参数可以是：Geometry或Geometry数组、Graphic或Graphic数组、Viewpoint对象、Camera对象。\n>\n> 本例中就使用了Camera对象（shiftCamera方法的返回值就是一个Camera）或Object对象（缩放到柏林）。\n>\n> 以上的参数是“target”，即目标。\n>\n> 后面还有一些可选的参数，用{}括起来作为一个Object对象：\n>\n> animate（boolean）、speedFactor（number类型）、duration（numer类型）、maxDuration（number类型）、easing（string或方法体）\n>\n> speedFactor是速度因子，很好理解，默认是1.\n>\n> duration是持续时间，如果有这个，那么speedFactor就会被覆盖。\n>\n> maxDuration是最大持续时间。\n>\n> easing是缓动方式。\n>\n> 通常，easing必选，speedFactor和duration、maxDuration三选一。\n>\n> 参数均可选。\n>\n> shiftCamera()方法\n>\n> 代码如下：\n>\n> ```\n> function shiftCamera(deg){\n>      var camera = view.camera.clone();\n>      camera.position.longitude += deg;\n>      return camera;\n> }\n> ```\n>\n> 给定一个deg（旋转角，角度制），camera的position的longitude值加上deg值。当然，deg要和longitude类型一样。\n>\n> position是一个空间点（Point类，继承自Geometry），longitude是经度。AJS4.2是默认用Web Mercator或WGS 84参考系的。\n>\n> 本例中默认漫游传入了60度，即每次按按钮就会把视角旋转60度。\n\n------\n\n \n\n我们再来看看第2-第5个漫游按钮。\n\n它们除了shiftCamera方法返回的Camera对象（target）外，还多了一个{}Object对象（option）。\n\n本例中，除了弹性缩放到柏林这个按钮外，其余都是用Camera对象和Object对象组合的方式，达到动画效果。\n\n我们当然可以直接用{}来定义一个Camera对象，就像弹性缩放到柏林这个按钮的方法体内写的。\n\n```javascript\n        on(dojo.query(\"#bounceBerlin\"), \"click\", function(){\n          view.goTo({             //这一层大括号定义的是Camera对象\n            position:\n            {           //这一层大括号定义的是Camera的position属性\n              x: 13.40,\n              y: 52.52,\n              z: 700000,\n              spatialReference:\n              {            //这一层是空间参考\n                wkid: 4326\n              }\n            },\n            heading: 0,        //Camera.heading\n            tilt: 0           //Camera.tilt\n          },\n          {      //这一层大括号就是跟上面类似的Object对象了\n            speedFactor: 0.3,\n            easing: customEasing\n          });//这个小括号结束的是goTo的范围\n        });\n```\n\n在Object对象中，easing参数可以指定为一个方法体（返回值是number即可）。这里customEasing就是这样的一个方法。（看起来略复杂）\n\n```javascript\nfunction customEasing(t) {\n     return 1 - Math.abs(Math.sin(-1.7 + t * 4.5 * Math.PI)) * Math.pow(0.5, t * 10);\n}\n```\n\n（插一句：如果在C#中，可不能随便这样给个方法名就行了，要用委托才能操作方法）\n\n关于easing这个参数的string值，大家可以自行到API查询，我简单列出这几个枚举：\n\n```\nlinear, in-cubic, out-cubic, in-out-cubic, in-expo, out-expo, in-out-expo\n```\n\n都可以自己试试，估计就是速度的不同而已。官方推荐小于1s的动画就用自己定义的方法体，超过1s的就用上面的枚举就行了。\n\n------\n\n \t\n\n总结。\n\n地图缩放动画的核心就是view对象的goTo()方法的使用。\n\ngoTo()方法在MapView类和SceneView类中都有提供，但是在它们的父类View类中没有。\n\n本文就对官方的API和例子进行学习，主要了解goTo()方法的参数的使用。\n\n用法：view对象.goTo(target, option);\n\n可以是：{定义Camera对象}+{Option参数}传入（前5个按钮）\n\n也可以是：直接传一个Camera对象+{Option参数}（最后一个按钮）。\n\nOption参数中的easing是“必选”的（不然就没动画效果了呀），speedFactor、duration、maxDuration是三选一。\n\nCamera对象可以自己用方法体返回，也可以直接用js的大括号定义。\n\n改变Camera对象的一些属性值，如经纬度，就可以达到改变视角。\n\n至于其他的，如Geometry、Graphic、Viewpoint就没有进行学习了，参考API可以解决，本文只是解读官方的例子达到入门效果。\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[5] 官方API大章节概述与内容转译","url":"/posts/1307306721/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6363915.html**\n\n------\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170204053145370-164038531.png)\n\n内容如上，截图自ESRI官网，连接：[ArcGIS API for JavaScript 4.2](https://developers.arcgis.com/javascript/latest/sample-code/index.html)（可能会跳转到4.3或者更高最新版本，如果有需要，到CSDN可以下载到4.2的离线文档）\n\n【Get Started】\n\n类似于绪论一样的东西，抽取了最需要关注的几个例子。如：加载Map和View，加载layers，使用弹出窗口，视觉化，与使用窗口小部件。（wtf居然没有分析你想搞事情啊web除了展示难道不应该有（）&&*……@）好吧，4.2刚出的时候分析功能确实不太全。\n\n[【Mapping and Views】](http://www.cnblogs.com/onsummer/p/6363912.html) \n\n最基础的，知道地图和视图的区别，能使用2D和3D地图，对地图的布局有一定的了解，对地图的动画也有小小的使用示例。还介绍了2D3D视图同步、鹰眼、指北针等功能。这一章是最基础的了，其中第一小节介绍了入口函数的参数意义。\n\n【Layers】\n\n这一章很庞大，和地理数据有关。按顺序读下去：\n\n支持多图层叠加显示\n\n支持要素图层、场景图层（直接把影像拔高，推出了一个盒子形状的立体物件的场景图层）、矢量瓦片图层（这个很厉害啊）、影像图层、流图层、CSV图层、OpenStreet地图图层、Web瓦片图层、点云图层（这个更厉害1.1亿的激光雷达点云数据都能加载进来）\n\n其中，对MapImageLayer和ImageryLayer有着重的介绍，前者不知道是什么东西，后者是影像图层（栅格图层）。这也是数据中最关键的了。\n\n最后我想问一下：图层这种东西，是怎么创建的（查API应该可以查到如何创建实例）？数据又如何从硬盘中获取？需要服务器环境吗？（尚待解决）\n\n回答上一句提到的问题。图层通过ArcGIS Server发布的各种服务创建，也可以通过Online或者Portal上的ID创建。\n\n【Visualization】\n\n这一章是符号的定制和色彩、样式的管理，主要是视觉方面的工作，在Web上不可能弄得很丑，Web最重要的功能就是“演示”，可视化这章就是为此而生。这一章内容繁多但是不难，简单看过去就是自定义符号、色彩设置、色带设置等，和桌面版的差不多。短时间内没法看完，以后待功能性章节完成学习后再进行攻读。\n\n[【Popups】](http://www.cnblogs.com/onsummer/p/6399346.html) \n\nPopups意思为弹出窗口，第一个就以坐标的显示为例子。\n\n弹出窗口也是一个相当基础的功能，因为有的查询功能的结果就需要用这种输出方式。\n\n紧接的是：使用弹出小窗口的模板、对popups的位置进行固定（Dock，上下左右相对固定）\n\n然后是在popups上加需要的内容，官方演示了表格、多媒体、文档和图表。\n\n最后，在弹出窗口上也是可以添加按钮的（官方演示了Zoom功能和测量功能），也可以定制自己的功能（跳转到别的地方什么的）\n\n【Graphics】\n\n这章简单，和GDI差不多的东西，往视图中添加图形。支持2D和3D视图添加。\n\n[【Searching】](http://www.cnblogs.com/onsummer/p/6399661.html) \n\n这章就是空间查询了。不过是基于widget的查询，底层似乎没给出。\n\n使用Search widget可以查询，这功能在国内的地图厂商上都有，并且他们很像。不同的是，这是WebGIS，而不是商用GIS，功能是可以自己定制的。\n\n当然，也可以对3D、2D地图进行筛选查询、点击查询。\n\nESRI也提供了最古老的方式——在表格上显示查询结果。\n\n[【Analysis】](http://www.cnblogs.com/onsummer/p/6414565.html)\n\n这一章是空间分析，虽然不及Desktop上的ArcMap和ArcGIS Pro那么强悍，不过对于基础的业务倒也足够。\n\nESRI已经说了，空间分析仍会在未来的版本中发布更新以与3.x产品线追平。\n\nWebGIS的空间分析主要是：缓冲区分析和网络分析。例子中的网络分析是求解最短路径，比桌面版的操作友好多了（见本人的ArcGIS 网络分析专辑）。\n\n此外官方还提供了：可视域分析、热点分析、查询高程（点高程变化和线路海拔变化等）。\n\n【Widgets】\n\n这属于UI的定制，大布局上可以用第三方JS库，在地图上的UI控件就交给ESRI吧。\n\n粗看下去，主要有：\n\nHome按钮控件、图层列表控件、图例控件、定位控件、地图打印到本地磁盘控件、追踪定位控件（平面的）、导航定位控件（用于导航）、快速布局控件（widget太多了可以用一个东西管理，view对象的ui属性）\n\nESRI强大到：widget似乎是可以自定义的（支持第三方JS库！如Angular、React），我看到了custom的字样，但是没有仔细往下看，因为提供的控件和功能已经满足大多数的需求了。甚至，widget还可以给它弄个皮肤。\n\n颤抖吧人类。\n\n【More 3D】\n\n这章跟数字高程模型有关，能使用大地高程进行3D可视化，并控制摄像机的位置和角度。\n\n同时，也可以把高程信息叠加到要素类上，进行高程3D显示。\n\n我还看到了一个好玩的东西：控制太阳（就是控制日照角度，根据时间），其实就是环境的控制。\n\nAJS的3D引擎是可以拓展的，甚至提及了Threejs公共3D引擎库（Threejs差评，文档忒少难读）。\n\nESRI提供了WebGL的检测功能，因为3D的支持需要WebGL，如果浏览器不支持，那肯定是不行的。\n\n【Other】\n\n这里是一些杂项，如从服务器上获取资料、许可，连接服务器等。\n\n \n\n------\n\n \n\n \n\nAPI从esri这个大类分下去，有以下一级模块及与一级模块并列的类：\n\n类：Basemap、Camera、Color、config、Graphic、Ground、kernel、PopupTemplate、request、Viewpoint、WebMap、WebScene\n\n一级模块：/core  /geometry /identity /layers /portal /renderers /support /symbols /tasks /views /webmap /webscene /widgets\n\n一些重要的二三级模块展示如下\n\n/core： /accessorSupport /workers\n\n/geometry： /support\n\n/layers： /support\n\n/renderers： /smartMapping/statistics      /smartMapping/symbology       /support\n\n/symbols： /support\n\n/tasks： /support\n\n/views： /3d    /layers   /ui\n\n/widgets： /support\n\n对于API Reference，等用到一定时候会做类图，未完待续。其实官方的API已经很不错了，但是就是没有中文版，需要用过的人去做一些工作。\n\n最后，善用API Reference。\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[4] 第二章其余感兴趣的例子","url":"/posts/642960823/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6363914.html**\n\n------\n\n> 目录如下（点击即可超链接跳转）：\n>\n> [视图存档](http://www.cnblogs.com/onsummer/p/6391517.html)\n>\n> [2D地图添加指南针](http://www.cnblogs.com/onsummer/p/6391517.html)\n>\n> [视图移动](http://www.cnblogs.com/onsummer/p/6391517.html)\n>\n> [鹰眼](http://www.cnblogs.com/onsummer/p/6389054.html) 【重要】\n>\n> [2D3D视图同步](http://www.cnblogs.com/onsummer/p/6391509.html) 【重要】\n>\n> [同视图不同数据同步](http://www.cnblogs.com/onsummer/p/6391513.html) 【重要】\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[3] 官方第二章Mapping and Views概览与解释","url":"/posts/814364469/","content":"**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6363912.html**\n\n------\n\n目录如下：\n\n![img](https://dev.tencent.com/u/ibrucekong/p/images/git/raw/master/arcgis-api-for-js-4.x/3-1.png)\n\n连接：[第二章 Mapping and Views](https://developers.arcgis.com/javascript/latest/sample-code/scene-local/index.html)\n\n根据本人体会，\n\n【这一章节主要是介绍地图（Map）和视图（View）的。】\n\n其中，Get started with MapView（2D）和 Get started with SceneView（3D）两节介绍了如何加载ESRI服务器或者开源的地图和视图。这两节介绍了很重要的概念：Map和View，Map即地理数据，而View代表视图。\n\n*View主要有两种，MapView和SceneView，前者是2D的，而后者是3D的，区别就是投影到哪里，前者投影到平面上，而后者投影到球体上，类似ArcScene和ArcGlobe。*\n\n`Load a WebMap`和`Load a WebScene`是加载某服务器上的Web地图或3D场景，官方的意思是支持ArcGIS Online or ArcGIS for Portal item导入为WebMap或WebScene，唯一的识别码就是ID。\n\n`Save a WebScene`，顾名思义，保存场景，几行代码即可保存场景（可以覆盖保存）。\n\n`WebScene slides`，这小节演示了给当前场景拍个照片然后存起来，需要的时候点击这个div（图片）即可读档。\n\n`Create a local scene`，这个不是很懂，貌似是把两个以上的scene叠加，形成一个新的，然后添加到SceneView中。\n\n`Map rotation`，这小节给2D地图（Map）添加了指北针小工具（wigdet？），允许2D地图旋转，可以用指北针恢复正北方向。\n\n`Using goTo() in a SceneView`，这小节演示了地图缩放动画。\n\n`Overview map`，这小节演示了如何使用鹰眼功能（其实就是2DMap和3DScene同步）。\n\n`View padding`，这小节演示了如何移动View的位置（例如需要一个面板在右边的时候，可以把地图的中心向左移动一些）\n\n`Custom basemap`，这小节使用了Basemap这个类，创造了Basemap实例后就可以把Map对象的基础数据替换成自己的数据了。\n\n`Synchronize two views`，这小节演示了如何把3D的SceneView和2D的MapView同步显示。\n\n`Swap web maps in the same view`，这小节演示了同一个view（如MapView）下，不同地理数据的切换（坐标不变）。例子：度娘地图中卫星地图和街道图的切换。\n","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[2] 显示3D地图","url":"/posts/1049908487/","content":"**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6363910.html**\n\n------\n\n3D地图又叫场景。\n\n由上一篇可知，\n\nrequire入口函数的第一个参数是字符串数组\n\n`[\"esri/Map\", \"esri/views/MapView\", \"dojo/domReady!\"]`\n\n这里，MapView就是2D的地图视图。\n\n所以，将2D地图改为3D地图，其实很简单，只需要把这个字符串数组的第二个引用改为\"esri/views/SceneView\"\n\n然后在第二个参数中修改对应的view代码即可。\n\n下面给出第二个参数（函数）的新代码\n\n```javascript\nfunction(Map, SceneView){\n  var map = new Map({\n    basemap: \"osm\", \n    ground: \"world-elevation\"\n  });//仍然使用osm基础地图\n  var view = new SceneView({\n    container: \"viewDiv\",     \n    map: map,               \n    scale: 50000000,         \n    center: [113.5, 30] \n  });//比例尺为1：5000万\n}\n```\n\n这里可以发现，view对象不是MapView类了，而是SceneView类。\n\n而且Map对象构造函数内出现了一个新的东西——ground。\n\n下面是ground的资料：\n\nground属性是表面数据，它可以是Ground类的实例。\n\n下面是SceneView类的资料：\n\nSceneView与MapView同样继承自View类。[SceneView](https://developers.arcgis.com/javascript/latest/api-reference/esri-views-SceneView.html)\n\n同样的，给出完整的html代码：\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no\">\n<title>Get started with SceneView - Create a 3D map</title>\n<style>\n  html, body, #viewDiv {\n    padding: 0;\n    margin: 0;\n    height: 100%;\n    width: 100%;\n  }\n</style>\n<link rel=\"stylesheet\" href=\"https://js.arcgis.com/4.2/esri/css/main.css\">\n<script src=\"https://js.arcgis.com/4.2/\"></script>\n<script>\nrequire([\n  \"esri/Map\",\n  \"esri/views/SceneView\",\n  \"dojo/domReady!\"\n], function(Map, SceneView){\n  var map = new Map({\n    basemap: \"osm\",\n    ground: \"world-elevation\"\n  });\n  var view = new SceneView({\n    container: \"viewDiv\", \n    map: map, \n    scale: 50000000, \n    center: [113.5, 30]  \n  });\n});\n</script>\n</head>\n<body>\n  <div id=\"viewDiv\"></div>\n</body>\n</html>\n```\n\n运行成功大概是这样的（稍微修改了比例尺为15万，坐标为114.3和30.5没错就是武汉）\n\n![img](https://dev.tencent.com/u/ibrucekong/p/images/git/raw/master/arcgis-api-for-js-4.x/2-1.png)\n\n \n\n------\n\n \n\n​      ps：如果感觉像平面的话可以把比例尺调回500w或者1000w，地面起伏不太明显可以调basemap为别的地图，坐标定位到山区。\n","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[1] 显示地图","url":"/posts/161947747/","content":"**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6363886.html**\n\n------\n\nArcGIS API for JavaScript 4.2直接从官网的Sample中学习，API Reference也是从官网翻译理解过来，鉴于网上截稿前还没有人发布过4.2的学习笔记，我就试试吧。\n\n什么是ArcGIS API for JS？这里就不多介绍了，最关键的一点是4.x版本与3.x版本的变化，按官方的意思是重新写了底层。\n\n笔记中规定：\n\nArcGIS API for JavaScript简称AJS\n\n使用CDN（即不配置本地环境）进行测试开发\n\n其余根据需要进行修改、增删。\n\n------\n\n\n要将地图显示在html页面上，那就要有一个块元素承接并执行渲染。\n\n本节以最简单、最低需求的2D地图显示为例。\n\n\n首先在html页面中肯定要有一个div，官方命名为“viewDiv”。然后就在js代码中对这个div进行输出即可。先贴出js代码的骨架部分（展开即可查看代码）\n\n这部分代码将位于4.2的js文件引用之下。\n\n```javascript\nrequire\n(\n    [\n      \"esri/Map\",\n      \"esri/views/MapView\",\n      \"dojo/domReady!\"\n    ] ,\n    function(Map, MapView) {\n        //你的代码\n    }\n);\n```\n\n\n现在对require入口函数的第一个参数（字符串数组）中的三个字符串的含义进行解释。\n\n这三个字符串与C#中的using命名空间、C++中的include头文件、Java中的#import类似，是对第二个参数所需要的功能进行引用。\n\n具体为什么是这三个字符串，后面再解释。\n\n第二个参数是一个函数（C#里会传委托吧大概忽略这个括号），这个函数的函数体如下：\n\n```javascript\nfunction(Map, MapView){\n  var map = new Map({\n    basemap: \"osm\" // 基础地图类型\n  });\n  var view = new MapView({\n    container: \"viewDiv\",  // 承接地图的块元素的ID\n    map: map,  // 地图对象，由上方new出\n    zoom: 8,  // 缩放级别\n    center: [114, 30]  // 中心经纬度\n  });\n}\n```\n\n我们对这里的两个实例化的对象map、view进行解释说明。\n\n【map对象是地图的数据部分，而view则是地图的可视化部分。】\n\nmap对象的创建参数，在本例中是basemap，查询参考可以知道使用了osm这一个类型的基础地图。basemap是一个类，在参考文档中也可以查询到。官方使用的是streets地图，而114，30附近streets是没有的，我切换到了osm地图。\n\nview对象构造时，拥有4个参数，注释中容易懂，就不做多的解释了，重要的是map对象是由上面new实例化出来的。\n\n至于JS的function参数和奇怪的构造函数，我也不多解释了，总之，Map和MapView两个名词，是esri/Map模块和esri/views模块下的两个类而已。\n\n这便是在第一个参数数组中前两个字符串的含义了。\n\n`[\"esri/Map\", \"esri/views/MapView\", \"dojo/domReady!\"] //第三个字符串暂时不解释`\n\n\n> 【Map类和MapView类的引用】\n>\n> 对Map类的信息截图如下：\n>\n> ![img](https://dev.tencent.com/u/ibrucekong/p/images/git/raw/master/arcgis-api-for-js-4.x/1-1.png)\n>\n> 继承自Accessor，子类有WebMap和WebScene。\n>\n> 构造函数的参数有一个：basemap类型的参数\n>\n> 对于Map对象的属性和方法，可以参考下文：\n>\n> [Map](https://developers.arcgis.com/javascript/latest/api-reference/esri-Map.html)\n>\n> 同理，MapView对象参考下文如下：\n>\n> [MapView](https://developers.arcgis.com/javascript/latest/api-reference/esri-views-MapView.html)\n>\n> MapView对象构造函数、属性和函数也写的很详细了。MapView继承自View类，而View类则继承自Accessor类。\n\n以上便为第二个参数的笔记。\n\n现在，贴出完整的html页面代码，可以自行复制粘贴到本地html文件，双击打开即可看到地图。\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no\">\n<title>Get started with MapView - Create a 2D map</title>\n<style>\n  html, body, #viewDiv {\n    padding: 0;\n    margin: 0;\n    height: 100%;\n    width: 100%;\n  }\n</style>\n<link rel=\"stylesheet\" href=\"https://js.arcgis.com/4.2/esri/css/main.css\">\n<script src=\"https://js.arcgis.com/4.2/\"></script>\n<script>\nrequire([\n  \"esri/Map\",\n  \"esri/views/MapView\",\n  \"dojo/domReady!\"\n], function(Map, MapView){\n  var map = new Map({\n    basemap: \"osm\"\n  });\n  var view = new MapView({\n    container: \"viewDiv\", \n    map: map,   \n    zoom: 8,\n    center: [114, 30] \n  });\n});\n</script>\n</head>\n<body>\n  <div id=\"viewDiv\"></div>\n</body>\n</html>\n```\n\n不出意外的话，会是这样子：\n\n![img](https://dev.tencent.com/u/ibrucekong/p/images/git/raw/master/arcgis-api-for-js-4.x/1-2.png)\n\n本人使用chrome 56浏览器，这是在网吧的机器，Win7+Chrome 55.\n\n------\n\n\n补充：\n\nlink和第一个script标签是对官方样式表和类库的引用，没有这俩是运行不了的。\n\n因为AJS是基于dojo的，所以需要在require的第一个字符串数组参数的第三个元素中使用dojo/domReady!，具体是为什么，官方例子有写，作为应用级别的开发就不深入了，有兴趣的同学可以试看AJS的框架什么的。\n","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"ArcGIS API for JavaScript 4.2学习笔记[0] AJS4.2概述、新特性、未来产品线计划与AJS笔记目录","url":"/posts/962944946/","content":"\n**ArcGIS API for JavaScript 4.x：**\n从3.x版本升级到4.x，变化比较大，学习、开发体验也会不一样。\n\n<!--more-->\n\n\n\n本系列是转载至博客园原创作者-[秋意正寒](https://home.cnblogs.com/u/onsummer/)-致敬!\n\n**原地址：https://www.cnblogs.com/onsummer/p/6391528.html**\n\n------\n\n> 放着好好的成熟的AJS 3.19不学，为什么要去碰乳臭未干的AJS 4.2？\n>\n> 4.2全线基础学习请点击[【直达】](http://www.cnblogs.com/onsummer/p/6391528.html#My)\n>\n> 4.3及更高版本的补充学习请关注我的博客。\n\n# ArcGIS API for JavaScript 4.2概述\n\nAJS 4.2，即ArcGIS API for JavaScript 4.2，是美国ESRI公司针对WebGIS市场推出的、利用JavaScript和Dojo开发的一款产品，它在2016年12月发布。而AJS 4.0 beta则在一年前就发布了。\n\n关于AJS3和AJS4选择的问题，现在可能AJS4还不够3某些方面厉害，尤其是Analysis部分等，这肯定的ESRI未来几年要巩固的方向。毫无疑问。如果急在眉梢需要开发一款2D数据处理很强的WebGIS应用，那么我还是推荐用AJS 3.19，毕竟已经很成熟了，AJS3的文档也满天飞。如果要适应未来5年的潮流，我建议还是从AJS4学起，假如没学过AJS3的话。\n\n学了AJS3也无所谓，AJS4有很多亮点的。\n\n所谓初生牛犊不怕虎，啃就是了。\n\n但凡有一定面向对象开发能力的地理信息系统相关的人都可以迅速上手AJS，这是我的感受。这篇blog是我读第一个AJS程序到现在为止写的，过去了不到10天，除去中间没看的时间静用时3天。所以，AJS不算很难。ps：我有C#+ArcObjects的基础，能独立完成一个Winform ArcEngine小项目。\n\n# AJS 4新特性\n\nAJS4.X（下文简称AJS4）是16年正式发布的产品，其新特性是：\n\n\\1. 3D支持\n\n这是在3.x版本（下文简称AJS3）里没有的，支持构建3D地图和3D场景了。有关更多3D内容可以查询官方的发布日志。\n\n\\2. 简化API\n\n把AJS3中不规范的类名规范化了，并简化了一批类名，重分类了一些类所在模块，更易用。详情见官方网站中AJS3-AJS4变化表。\n\n\\3. 直接使用属性\n\n像C#的属性一样，可以直接用“.”运算符调用属性进行取值、赋值，而不用再调setProperty()、getProperty()这种不简洁的写法。\n\n\\4. 对事件监听有变化\n\n在AJS4中已经不再通过propertyname-change事件监听属性变化，现在只需要使用.watch(property, callback)方法来监听特定的属性更改。当属性发生变化时，回调函数将会接一系列参数，包括，受新值、旧值、属性名、监听对象。\n\n\\5. 数据和视图分开\n\n在AJS3中，Map和Layer对象要处理绘制地图，但是在AJS4中被单独剥离出来称为View对象了（2D为MapView，3D为SceneView）\n\nView.map属性可以引用Map对象，一个Map对象可以被多个View引用。\n\n\\6. 仅支持AMD模式\n\nAMD，不是超微半导体那个AMD，是异步模块定义的意思。由于AJS 4采用了Dojo框架和ECMAScript6（即最新规范的JavaScript）实现，AJS就得以支持开发大型Web平台。\n\n具体这个东西是什么，各位看官还请移步比我更强的博客中查阅【Asynchronous Module Definition】\n\n\\7. Promise\n\n异步操作的福音，then()方法简直就是多层回调的救命稻草——夸张了点。不过Promise作为2015年ECMAScript新标准中的一个，能马上被AJS采用，确实不错，紧跟潮流。\n\n有些地理处理任务是在服务器端异步完成的，甚至异步内的回调函数还可能是异步的，多层异步的回调函数可不太好写。官方就以buffer为例说明了then()的好处。\n\n有些类继承了Promise类，而有的属性就是Promise类型的，有大量的方法返回值类型也是Promise类型的。\n\n# AJS 4.2新特性\n\n\\1. 支持自定义widget\n\n官方给出的例子中，就可以利用前端框架React和AngularJS创建第三方widget。\n\n\\2. 更多widget\n\nLayerList和Print，即图层列表和打印小部件提供了！\n\n\\3. 升级矢量瓦片图层并提供支持\n\n\\4. MapView和SceneView提供了更多的事件兹磁。\n\n\\5. 激光雷达点云数据的支持\n\n\\6. 高程查询API\n\n\\7. 允许自定义goTo()方法\n\n# AJS 4.3以及更高版本未来将支持的特性\n\n数据编辑（Editing）\n\n绘图工具（Draw and EditTools）\n\n支持更多的图层类型：GeoRSSLayer, KMLLayer, WMSLayer 和 WMTSLayer\n\n支持更多的着色器（Renderer）\n\n支持更多的小部件：BasemapGallery, Directions, FeatureTable, OverviewMap, analysis widgets etc.（卧槽最后两个要爆炸快点出啊）\n\n支持图例控件\n\n编辑WebMap（Writing WebMap）\n\n其他的不太好翻译，就直接复制粘贴了：Temporal awareness: rendering and filtering/GeoEnrichment/Extensions for Operations dashboard/DataReviewer tasks\n\n————\n\n更为细致一些的内容：\n\n我摘抄一些觉得重要的，其余直接参考官方的对比表吧。\n\ngraphicsUtils、栅格影像的空间参考、获取Popups的标题和内容、更多鼠标键盘事件、启用/禁用导航、修改Graphics、FeatureLayer的选择功能/编辑功能/查询附件、BookmarkItem小部件、Bookmarks小部件、ColorPiker小部件、高程滑块小部件、LayerSwipe小部件、测距小部件、透明小部件、比例尺小部件、符号选择器小部件、时间滑块小部件等。\n\n# AJS 4 产品升级时间线\n\n按照ESRI的习惯，3~4个月发布一次新版本的话，2017年能看到AJS 4.3和4.4的发布，一个是在3月，一个是在7月（AJS4.3和AJS4.4时间官方已经给出）。\n\n//2017.03.06已发布4.3\n\n而AJS3则会在2017年停止更新，但是仍然会提供CDN支持直到AJS4完全替代它。AJS3估计还有1-2个版本更新了，更新的内容也不是很起眼，所以完全算是一款成熟的API，剩下的只是小修小补。\n\n看下图便知：\n\n![img](https://images2015.cnblogs.com/blog/1097074/201702/1097074-20170213064313910-565181704.png)\n\n \n\n（图截取自2016年1月的文件）\n\n图中的表格可以看出，AJS1和AJS2已经退休了，AJS3仍然在提供支持，AJS4是2016年3月发布的测试版。\n\nAJS3将于2年后退休，而AJS4将于3年多后退休。\n\nAJS3将在2017年1月进入成熟运行阶段。\n\nAJS4将于2018年5月进入成熟运行阶段，截至写这篇博客时，还有大概一年多点时间看着AJS4的成长。\n\n为什么AJS3和AJS4只差1年就退休了呢？而发布时间却差了整整4年。我猜，AJS4只是ESRI对3D的一次试水，关键还是与ArcGIS Pro的结合，以及为AJS5做准备。WebGIS已经是ESRI的重心所在，它怎么可能不发力于此呢？尤其是3D这块、大数据这块、云计算这块。\n\n# 我的AJS 4.2学习笔记目录\n\n方便查阅，点击就跳转。\n\n[ArcGIS API for JavaScript 4.2学习笔记[0\\] ★AJS4.2概述、新特性、未来产品线计划与AJS笔记目录](http://www.cnblogs.com/onsummer/p/6391528.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[1\\] 显示地图](http://www.cnblogs.com/onsummer/p/6363886.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[2\\] 显示3D地图](http://www.cnblogs.com/onsummer/p/6363910.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[3\\] ★官方第二章Mapping and Views概览与解释](http://www.cnblogs.com/onsummer/p/6363912.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[4\\] 第二章其余感兴趣的例子](http://www.cnblogs.com/onsummer/p/6363914.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[5\\] 官方API大章节概述与内容转译](http://www.cnblogs.com/onsummer/p/6363915.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[6\\] goTo()地图动画](http://www.cnblogs.com/onsummer/p/6388084.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[7\\] 鹰眼（缩略图）](http://www.cnblogs.com/onsummer/p/6389054.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[8\\] 2D与3D视图同步](http://www.cnblogs.com/onsummer/p/6391509.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[9\\] 同一种视图不同数据（Map）同步](http://www.cnblogs.com/onsummer/p/6391513.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[10\\] 2D添加指北针widget、视图保存、视图padding（第二章完结）](http://www.cnblogs.com/onsummer/p/6391517.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[11\\] ★官方第五章Popups（弹窗）概览与解释](http://www.cnblogs.com/onsummer/p/6399346.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[12\\] View的弹窗（Popup）](http://www.cnblogs.com/onsummer/p/6399628.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[13\\] Layer的弹窗（PopupTemplate）](http://www.cnblogs.com/onsummer/p/6399632.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[14\\] 弹窗的位置、为弹窗添加元素](http://www.cnblogs.com/onsummer/p/6399651.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[15\\] 弹窗内容的格式与自定义格式](http://www.cnblogs.com/onsummer/p/6399654.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[16\\] 弹窗自定义功能按钮及为要素自定义按钮（第五章完结）](http://www.cnblogs.com/onsummer/p/6399654.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[17\\] ★官方第七章Searching（空间查询）概览与解释](http://www.cnblogs.com/onsummer/p/6399661.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[18\\] 搜索小部件](http://www.cnblogs.com/onsummer/p/6421297.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[19\\] 搜索小部件——使用更多数据源](http://www.cnblogs.com/onsummer/p/6421459.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[20\\] 使用缓冲区结合Query对象进行地震点查询【重温异步操作思想】](http://www.cnblogs.com/onsummer/p/6421488.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[21\\] 对3D场景上的3D要素进行点击查询【Query类学习】](http://www.cnblogs.com/onsummer/p/6421503.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[22\\] 使用【QueryTask类】进行空间查询](http://www.cnblogs.com/onsummer/p/6421507.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[23\\] 没有地图如何进行查询？【FindTask类的使用】](http://www.cnblogs.com/onsummer/p/6421513.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[24\\] IdentifyTask类的使用（第七章完结）](http://www.cnblogs.com/onsummer/p/6421517.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[25\\] ★官方第八章Analysis（空间查询）概览与解释](http://www.cnblogs.com/onsummer/p/6414565.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[26\\] 缓冲区分析【基于geometryEngine类】](http://www.cnblogs.com/onsummer/p/6421532.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[27\\] 网络分析之最短路径分析【使用RouteTask类】](http://www.cnblogs.com/onsummer/p/6421540.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[28\\] 可视域分析【使用Geoprocessor】](http://www.cnblogs.com/onsummer/p/6682666.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[29\\] 热点(密度)分析——以报警频率为例【使用Geoprocessor】](http://www.cnblogs.com/onsummer/p/6682674.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[30\\] 点和线高程查询（第八章完结）](http://www.cnblogs.com/onsummer/p/6682677.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[31\\] (补充学习)Task类](http://www.cnblogs.com/onsummer/p/6682682.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[32\\] ★(补充学习)Graphic章概述](http://www.cnblogs.com/onsummer/p/6685048.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[33\\] ★(补充学习)Layer章概述](http://www.cnblogs.com/onsummer/p/6685056.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[34\\] (补充学习)弹窗章节再思考](http://www.cnblogs.com/onsummer/p/6685069.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[35\\] (补充学习)其他杂七杂八](http://www.cnblogs.com/onsummer/p/6685078.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[36\\] AJS4.x更高版本新特性后续学习目录](http://www.cnblogs.com/onsummer/p/6685083.html)\n\n[ArcGIS API for JavaScript 4.2学习笔记[37\\] AJS类图（使用XMind制作）](http://www.cnblogs.com/onsummer/p/6685088.html)\n\n—————— 以下为姐妹篇——————\n\n[ArcGIS API for JavaScript 4.3 与 ArcGIS Server 联动使用【地图服务】](http://www.cnblogs.com/onsummer/p/6670519.html)   对Server的各种服务在AJS中的使用，请查看这篇的末尾。\n\n[ArcGIS API for JavaScript 4.3 与 3.20 新特性【2017.03.06】](http://www.cnblogs.com/onsummer/p/6511911.html)\n\n[使用ArcGIS for Server 10.4 发布NAServer](http://www.cnblogs.com/onsummer/p/6819059.html) 顺带介绍了AJS中三个网络分析Task\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["ArcGIS","ArcGIS API for Javascript 4.2","WebGIS","AJS"],"categories":["ArcGIS API for JavaScript 4.x"]},{"title":"修改Docker下的MySQL密码校验方式","url":"/posts/2058601592/","content":"\n**Docker学习：**\n\n由于MySQL在版本升级后，验证加密的方式改变了，在使用Navicat连接时会报错，因此下记录解决方法。\n\n<!--more-->\n\n当使用docker的MySQL时，遇到了navicat无法连接mysql的情况，给出了两种解决方法，一是升级navicat驱动，暂时跳过该方法；二是修改mysql密码校验方式。\n\n```\n# 首先启动docker的mysql数据库服务\n$ docker start docker-mysql\n# 进入docker-mysql的命令行模式\n$ docker exec -it docker-mysql bash\n# 默认进入root用户下\n$ root@921c40c1c9d6:/#\n# 进入mysql命令，回车输入docker-mysql密码\n$ mysql -u root -p\n# 进入mysql数据库表\n$ use mysql;\n# 修改密码方式\n$ alter user 'root'@'%' identified with mysql_native_password by 'your password';\n# 两次 exit 退出命令行界面\n```\n使用Navicat连接mysql数据库成功。\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>\n","tags":["终端","Docker"],"categories":["languages"]},{"title":"Docker无法使用vim","url":"/posts/2392351684/","content":"\n**Docker学习：**\n\n从Docker仓库中下载的容器，由于需要进行自定义设置，但是环境却没有提供能编辑的功能，连VIM都未提供，记录在设置MySQL时遇到没有VIM环境的解决方法。\n\n<!--more-->\n\n当使用docker的MySQL时，遇到了navicat无法连接mysql的情况，给出了两种解决方法;\n* 一是升级navicat驱动；\n* 二是修改mysql密码校验方式。\n\n当时想看看mysql容器的配置文件，结果使用`vim`都报\n```\nbash: vi: command not found\n```\n显然是mysql基于的Linux容器没有安装vim，下面来联网安装一下：\n```\n# 安装vim\n$ apt update\n$ apt install vim\n```\n然后可以愉快的编辑了。\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>\n","tags":["终端","Docker"],"categories":["languages"]},{"title":"Splice和Slice引发的血案","url":"/posts/2464790768/","content":"\n**一字千里，何况是在代码里：**\n\n生活中一字之差，意思能千差万别，在代码中差了一字，运行结果更是差之千里。\n\n<!--more-->\n\n在项目中遇到了对数据进行Copy，实现浅拷贝想到了用Slice，但是却错写成了Splice，引发了一系列问题。\n\n下面借花献佛，讲解一下slice和splice的区别：\n\n>  slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。\n>\n> 注意：该方法不会改变原数组，而是返回一个子数组，如果想删除数组中的一段元素，应该使用Array.splice()方法。\n>\n> start参数：必须，规定从何处开始选取，如果为负数，规定从数组尾部算起的位置，-1是指最后一个元素。\n> end参数：可选（如果该参数没有指定，那么切分的数组包含从start倒数组结束的所有元素，如果这个参数为负数，那么规定是从数组尾部开始算起的元素）。\n\n\n\n```javascript\nvar arr = [1,2,3,4,5];\nconsole.log(arr.slice(1));//[2,3,4,5]  选择序列号从1到最后的所有元素组成的新数组。\nconsole.log(arr.slice(1,3))//[2,3]  不包含end，序列号为3的元素\n```\n\n\n\n> splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目。（该方法会改变原数组）\n>\n> splice（index,howmany,item1,...itemX）\n>\n> index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。\n> howmany参数：必须，要删除的数量，如果为0，则不删除项目。\n> tem1,...itemX参数：可选，向数组添加的新项目。\n\n\n\n```javascript\nvar arr = [1,2,3,4,5];\nconsole.log(arr.splice(2,1,\"hello\"));//[3]  返回的新数组\nconsole.log(arr);//[1, 2, \"hello\", 4, 5]  改变了原数组\n```\n\n原文：[https://blog.csdn.net/xiaoqingpang/article/details/79108005](https://blog.csdn.net/xiaoqingpang/article/details/79108005)\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["编程语言","心得"],"categories":["languages"]},{"title":"再见,我的青春 ——《请回答1988》","url":"/posts/139445933/","content":"\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/1988.jpg\" alt=\"\">\n</div>\n\n**暗恋终究有风险,但愿青春无悔：**\n\n提起韩剧,很多人下意识会认为是无脑爱情剧,豆瓣评分也会很低,特别是对于只看美剧的男生来讲,漫威、DC的烧钱特效,好不过瘾,看韩剧简直就是天方夜谭。但是对于《请回答》系列的《请回答1988》,豆瓣评分及其之高,堪称神剧,不信来刷,我在第一集等你。\n\n<!--more-->\n\n<div style=\"text-align: center;\"><img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/1988-douban.png\" alt=\"1988\"></div>\n\n《请回答1988》当前的豆瓣评分是[9.7](https://movie.douban.com/subject/26302614/),该剧在官方定义中是一部爱情喜剧,而多数人在刷剧时,却硬生生的把喜剧刷成了泪目剧,每一集的感动时间就像美剧《Supernatural》中兄弟两个的感动时间一样(Hey, 美人丁)。此剧与2015年11月6日在韩国上映,是一部距离我们比较近的韩剧,而不是那种被冠以经典二字的老剧,不像《越狱》《行尸走肉》《权力的游戏》那么早就面世那么早,但是却同样拥有着巨大魔力俘获了众多人的心。\n\n<div style=\"text-align: center;\">![1988](https://coding.net/u/ibrucekong/p/images/git/raw/master/1988-all.png)</div>\n\n首次接触《请回答1988》是在2017年12月份,对于韩剧中的细腻(腻歪),不如美剧宏大场面看的那么爽、那么疯狂,而我又对剧很挑剔,看的美剧要么经典,要么上当时的TOP,所以对于韩剧稍微有点不待见的节奏。可是,看了《请回答1988》第一集过后,深陷其中,引人入胜,无法自拔。\n\n最近用了半个月的时间二刷,在下班之余、睡前(害的熬夜)刷完,看的很过瘾。\n\n<div style=\"text-align: center;font-weight: bold;font-size: 1.5rem; color: red\">\n\t以下是豆瓣相关链接\n</div>\n对于好剧好电影,在刷完之后总会去点评网站细细品味在观看时未能察觉到的、未能留意到的细节。下面从国内的豆瓣上摘取了一些经典评论,如果喜欢,并且不怕剧透的可以去品读下。\n\n<blockquote>[那一场无疾而终的暗恋-88恋爱解析--有片叶子(作者)](https://movie.douban.com/review/7743563/)\n\n   1988对我来说不是一个爱情剧，它理所当然的应该是一个怀旧青春剧。\n   在青春中，爱情只是其中的一部分，甚至在青春的爱情里，闪光的不是结局，而是那青涩懵懂的过程。\n\n   18集毫无疑问是属于正焕的，雨中的独白，错过的时机，自我剖析的悔恨，正焕的爱情在独白中已经交代，而后餐厅借戒指的表白......\n</blockquote>\n\n看来大家的入笔都是从狗焕开始,毕竟青春爱情剧还是要有感情线,在这一个没有男主的剧中狗焕却是隐形的贯穿其中,狗焕的爱情从刚一开始到红灯亮起时就注定了暗恋风险太大,想要追悔依然天不助。\n\n<blockquote>[细数1988中的事件背景和人物 不断更新--作者(小柒)](https://movie.douban.com/review/7676474/)\n\n   1988完结了，因为正焕不是最后的老公纷纷去打1分的你们，你们就忘记了刚开始看这部剧的时候给你们自己带来的感动了吗?\n</blockquote>\n\n答主开头就为该剧抱不平(都9.7分了,还不满意...是,不满意),表示为狗焕不是最后的老公而打1分的人的愤慨,然后晒出狗焕和德善剧中无缘,但现实却摆脱了狗的称谓,勇敢的向德善发起爱情宣言。并对每一集进行了剖析,指出每一集中的事件的背景和人物,对于如此用心良苦的编剧,点赞！\n\n<blockquote> [神剧请回答1988埋的梗你看懂了多少--凰Suk(作者)](https://movie.douban.com/review/7754487/)\n\n   其实个人并不建议想看少女心和爱情线的小伙伴们看1988，如果想看爱情喜剧那你大可以去找洪氏姐妹，想看成功商业爱情剧去找金编剧，而请回答系列，玩儿的一直是情怀，相比97和94，88表达的东西更多更杂也更贴近生活，这也是为什么88在韩网和内地平台上分数不如97和94，因为大部分人都想单纯地看看爱情线，冒冒粉红色泡泡。\n\n   开始对剧中的梗进行分析......\n</blockquote>\n\n该答主剖析的梗很到位,开头先给出了看此剧的态度,说少女❤和爱情线的小伙不建议看,我是不赞同的,对于美好的事物每个人都有欣赏的权利,尽管是(单身)狗。\n\n<blockquote>[最后幸好是你--青木(作者)](https://movie.douban.com/review/7741010/)\n\n   作为2015年韩国最受期待的现象级大剧《请回答1988》落下了帷幕。“正八”党没等来逆转，德善还是属于崔泽。这样的结局一度让“焕善党”把《88》推上了风口浪尖，他们不明白为什么前面的正牌男主到了后面基本沦为了男四，前面的铺垫，前面的伏笔，前面的勾勒，到后来连交代都省去喂了狗。于是质疑，诋毁就开始铺天盖地。\n   我不属于“泽善粉”也不属于“焕善粉”，不过说实话最开始的时候，按照《请回答XX》这个系列的尿性，基本大家都认为老公应该是狗焕，我也这么认为，心底里最大的期望也不过是不要太虐阿泽，毕竟阿泽几乎是用出了下棋以外所有的时间和生命去爱着德善。但不知道为何心底里总有德善和阿泽在一起的希冀..\n</blockquote>\n\n答主首先喊出了弹幕中出现最多的两个党派“狗善党”、“泽善粉”,并对编剧把狗焕\"丑帅\"的人物刻画的轻车熟路表达了赞许。\n\n说到党派站队,我还是倾向于站“焕善党”的,可能我是从狗焕的身上看到了太多自己的影子,认同感油然而生,勿拍砖。特别在最后,德善推门进来看到一群小伙伴再看英雄本色时,恍然如梦,顿时一怔,想到狗焕,若此为梦,可还木讷！\n\n最后,特别要感谢一下《请回答1988》的编剧,简直神人,对人物内心的拿捏恰到好处;再者感谢剧中的每一位演员,神剧情没有演员的完美演绎也不会称为神剧;然后感谢那些还在为此剧疯狂的人,因为物以类聚,人以群分,对于好剧的感染力使得大家同在一个\"屋檐下\"。\n\n从第一集又看到第一集,希望下一次的第一集有你一起看,我在第一集等你。\n\n**断断续续的续...**\n\n<blockquote>搞怪的不是红绿灯，不是时机，而是我数不清的犹豫\n\n “哎一古，成社长。哎一古，金社长。”\n\n 德善的抖腿舞，啊哈哈\n\n 三兄弟的《消防车》\n\n咩～咩～咩～～～\n\n冬天最温馨的事就是和《请回答》一起度过...\n\n把最好的都给了朋友、兄弟和国家，狗焕你留下了啥...\n\n男生站”狗善党“（看到自己的影子），女生站”泽善党“（女生的看法）\n\n啊，1988的后劲太TM大了...\n\n大人们只是在忍，只是在忙着大人们的事，只是在用故作坚强来承担年龄的重任，大人们也会疼。\n\n永远没有顾客的凤凰堂，确实双门洞的最大赢者。\n\n1988是一部后劲很大的剧。\n\n1988里面没有坏人，如果非要说有，那就是时光。\n\n娃娃鱼懂所有人，所有人却不懂娃娃鱼。\n\n</blockquote>\n歌单很多，大家网上找找>>>>[〖请回答1988〗这几首就好了](https://music.163.com/#/playlist?id=2531631787)\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["韩剧","请回答1988"],"categories":["tips"]},{"title":"吾爱破解论坛2018年11月11日开放注册通知","url":"/posts/3256505474/","content":"**吾爱破解论坛注册喜讯：**\n吾爱开放注册又又来了，此次是2018年第三次开放注册，在今年前两次未能成功上车的小伙伴，这次可要抓住了，又是正值周末，又是天时地利人和，赶快整理好自己的注册资料，期待“11.11”的到来吧。\n\n<!--more-->\n\n<div style=\"text-align: center;font-weight: bold;font-size: 2rem; color: red\">\n\t喜讯、喜讯、喜讯\n</div><div style=\"text-align: center;font-weight: bold;font-size: 1.5rem\">\n\t<span>吾爱破解论坛开通开放注册</span>\n\t<span>2018年11月11日12:00-14:00和20:00-22:00</span>\n</div><div style=\"text-align: center;font-weight: bold;font-size: 1.5rem;padding-top: 0;margin-top: 0;height: 106px;line-height: 106px\"><a href=\"https://www.52pojie.cn/?fromuid=575811\" style=\"text-align: center;\">我要吾爱</a></div>\n<div></div>\n\n***注册注意事项：***\n\n1. 吸取上次上车失败的教训！！！\n2. 注意不要错过注册时间\n3. 认真读注册须知（需要等10分钟）\n4. 事先把注册信息写在本子或word里（独一无二的邮箱和用户名） [需要准备什么](https://www.52pojie.cn/misc.php?mod=faq&action=faq&id=15&messageid=16)\n5. 耐心检查填写内容（看是否都符合要求）\n6. 邮箱验证阶段，有的要到邮箱的垃圾箱中查看有没有验证邮件，而有的邮箱则需要设置白名单才能收到验证邮件 [帮助](https://www.52pojie.cn/thread-98585-1-1.html)\n7. 提醒一下，在注册成功后，要记得保持活跃度哦，不要只在官网签到，还要有互动（发帖、回复），不然会被清理的。\n\n<div style=\"text-align: center;font-weight: bold;font-size: 1.5rem\">\n\t祝愿小伙伴们都能获得自己的吾爱账号！\n</div><div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["活动","吾爱破解"],"categories":["tips"]},{"title":"济南的中秋","url":"/posts/4186109665/","content":"<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/jinan-mid-autumn.png\" alt=\"\">\n</div>\n\n<!--more-->\n\n<br >\n<br >\n<br >\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <span style=\"font-size: 3rem;color: #696969;background-image: -webkit-linear-gradient(92deg, #d4290e, #ff71fb);-webkit-background-clip: text;-webkit-text-fill-color: transparent;-webkit-animation: hue 60s infinite linear;\">中秋一人，亦可三人成酒！</span>\n</div>\n\n<br >\n\n<br >\n\n<br >\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["中秋","济南"],"categories":["tips"]},{"title":"BIMserver入门笔记 - 02登录及模型展示","url":"/posts/3230248873/","content":"**BIMserver登录及模型展示：**\nBIMserver资料较少，没有成熟的接口文档，没有成熟的示例程序，但是BIMserver为我们提供了一个运维程序、示例数据，在Github中的[opensourceBIM](https://github.com/opensourceBIM)这个开源组织，给开发者提供了不少源码级的学习内容。从运维程序中我们可以梳理出BIMserver的执行过程，方便我们二次开发。\n\n<!--more-->\n\n1. [BIMserver入门笔记 - 01环境搭建、数据导入及预览](../3869274485/)\n\n2. BIMserver入门笔记 - 02登录及模型展示\n\n从上一节我们了解了BIMserver的安装配置和运维的使用，但是在项目中我们不可能去直接用BIMserver的运行界面，需要我根据自己的项目需求来自定义自己的BIM展示界面和功能，所以我们就要从开发者角度去审视BIMserver。\n\n### 准备什么\n\n既然是开发者，前端就至少要懂前端的，后端至少要懂后端的，最好两者都熟悉。准备工作除了能搭建起BIMserver环境，还要有以下的几个特点（建议）：\n\n* 一件趁手的兵器——IDE（前端就WebStorm咯，涉及到后台就IDEA咯）\n* 一个性能不错的本子——内存和CPU性能要好，关键还要有不错的显卡\n\n### 需要什么\n\n* 一个敢于钻研的劲头\n\n* 一个不服输、有韧性的心\n\n*新兴的技术或者前沿的技术，必要要耐得住性子*\n\n除了精神上的鼓舞，我还要掌握一些查资料的技能，特别是在对BIMserver二次开发中，资料少之又少，整个腾讯就两个群（一个群人数不超过一只手的手指头数）。另外官方也没有提供`Step by step`和接口文档，示例代码也是少的可怜，Stack Overflow、CSDN和博客园中资料也是凤毛麟角，所以二次开发的参考资料还是去查看官方的[接口源码](https://github.com/opensourceBIM/BIMserver/tree/parent-1.5.88/PluginBase/src/org/bimserver/shared/interfaces)，比如最常用的[接口源码](https://github.com/opensourceBIM/BIMserver/blob/parent-1.5.88/PluginBase/src/org/bimserver/shared/interfaces/ServiceInterface.java)。\n\n### 万里长征第一步\n\n万事开头难，先起个[Hellobim](https://github.com/ibrucekong/hellobim/)吧！\n\n#### 设计布局\n\n```html\n<div id=\"maincontainer\">\n  <div id=\"topsection\">\n    <h1>Hellobim</h1>\n  </div>\n  <div id=\"contentwrapper\">\n    <div id=\"colmid\">\n      <div id=\"colright\">\n        <div id=\"col1wrap\">\n          <div id=\"col1pad\">\n            <div id=\"viewerContainer\">\n            </div>\n          </div>\n        </div>\n        <div id=\"treeContainer\" class=\"bimsurfer-static-tree\">\n        </div>\n        <div id=\"dataContainer\" class=\"bimsurfer-metadata\">\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n```\n\n#### 变量配置\n\n由于JavaScript代码比较多，所以拆分成了三部分，一个是变量配置模块，一个是登录模块，一个是模型加载展示。\n\n```javascript\nvar projectName = 'test1'; // address地址下的BIMserver服务中必须有test1项目，而且还要有模型\nvar address = \"http://192.168.1.116:8082\"; // 这三个是在安装BIMserver时配置的地址、账户和密码\nvar account = \"admin@163.com\";\nvar password = \"1234567890\";\nvar token, poid, lastRevisionId; // 这三个是在模型加载时需要用到的\nvar metadata; // 这是右侧元数据\n```\n\n#### 登录\n\n```javascript\n// 登录代码\ndocument.addEventListener(\"DOMContentLoaded\", function (event) {\n  function loadFromBimserver(address, username, password, target) {\n    var client = new BimServerClient(address);\n    client.init(function () {\n      client.login(username, password, function () {\n        // 根据项目名称获取该项目的模型场景\n        client.call(\"ServiceInterface\", \"getAllProjects\", {\n          onlyTopLevel: true,\n          onlyActive: true\n        }, function (projects) {\n          var totalFound = 0;\n          projects.forEach(function (project) {\n            if (project.name === projectName) {\n              token = client.token;\n              poid = project.oid;\n              lastRevisionId = project.lastRevisionId;\n            }\n          });\n        });\n      }, function (error) {\n        console.error(error);\n      });\n    });\n  }\n\n  try {\n    loadFromBimserver(address, account, password);\n  } catch (e) {\n    console.log(e);\n  }\n});\n```\n\n#### 模型加载及展示\n\n```javascript\n// 加载模型并展示\nrequire([\"bimsurfer/src/BimSurfer\",\n    \"bimsurfer/src/BimServerModelLoader\",\n    \"bimsurfer/src/StaticTreeRenderer\",\n    \"bimsurfer/src/MetaDataRenderer\",\n    \"bimsurfer/lib/domReady!\"],\n  function (BimSurfer, BimServerModelLoader, StaticTreeRenderer, MetaDataRenderer) {\n\n    function processBimSurferModel(bimSurferModel) {\n\n      bimSurferModel.getTree().then(function (tree) {\n\n        var domtree = new StaticTreeRenderer({\n          domNode: 'treeContainer'\n        });\n        domtree.addModel({name: \"\", id: lastRevisionId, tree: tree});\n        domtree.build();\n        metadata = new MetaDataRenderer({\n          domNode: 'dataContainer'\n        });\n\n        metadata.addModel({name: \"\", id: lastRevisionId, model: bimSurferModel});\n\n        bimSurfer.on(\"selection-changed\", function (selected) {\n          domtree.setSelected(selected, domtree.SELECT_EXCLUSIVE);\n          metadata.setSelected(selected);\n        });\n\n        domtree.on(\"click\", function (oid, selected) {\n          if (selected.length) {\n            bimSurfer.viewFit({\n              ids: selected,\n              animate: true\n            });\n          }\n          bimSurfer.setSelection({\n            ids: selected,\n            clear: true,\n            selected: true\n          });\n        });\n\n      });\n    }\n\n    var bimSurfer = new BimSurfer({\n      domNode: \"viewerContainer\"\n    });\n    window.bimSurfer = bimSurfer;\n\n    var bimServerClient = new BimServerClient(address, null);\n    bimServerClient.init(function () {\n\n      bimServerClient.setToken(token, function () {\n        var modelLoader = new BimServerModelLoader(bimServerClient, bimSurfer);\n\n        var models = {}; // roid -> Model\n\n        var nrProjects;\n\n        function loadModels(models, totalBounds) {\n          var center = [\n            (totalBounds.min[0] + totalBounds.max[0]) / 2,\n            (totalBounds.min[1] + totalBounds.max[1]) / 2,\n            (totalBounds.min[2] + totalBounds.max[2]) / 2\n          ];\n\n          var globalTransformationMatrix = [\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            -center[0], -center[1], -center[2], 1\n          ];\n          for (var roid in models) {\n            var model = models[roid];\n            modelLoader.setGlobalTransformationMatrix(globalTransformationMatrix);\n            modelLoader.loadFullModel(model).then(function (bimSurferModel) {\n              processBimSurferModel(bimSurferModel);\n              //填充下拉框\n              getModelOidAndName(bimSurferModel);\n            });\n          }\n        }\n\n        function getModelOidAndName(thisModel) {\n          var modelObj = thisModel.apiModel.objects;\n          Object.keys(modelObj).forEach(function (key) {\n            if (modelObj[key].object.hasChildren === undefined) {\n              var option = document.createElement(\"option\");\n              $(option).val(key);\n              if (modelObj[key].object.Name === undefined || modelObj[key].object.Name === \"\") {\n                $(option).text(key);\n              } else {\n                $(option).text(modelObj[key].object.Name);\n              }\n              $('#select').append(option);\n            }\n          });\n        }\n\n        bimServerClient.call(\"ServiceInterface\", \"getAllRelatedProjects\", {poid: poid}, function (projects) {\n          nrProjects = projects.length;\n          var totalBounds = {\n            min: [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE],\n            max: [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE]\n          };\n\n          projects.forEach(function (project) {\n\n            if (project.lastRevisionId !== -1) {\n              //lastRevisionId\n              bimServerClient.getModel(project.oid, project.lastRevisionId, project.schema, false, function (model) {\n                models[project.lastRevisionId] = model;\n\n                bimServerClient.call(\"ServiceInterface\", \"getModelMinBounds\", {roid: project.lastRevisionId}, function (minBounds) {\n                  bimServerClient.call(\"ServiceInterface\", \"getModelMaxBounds\", {roid: project.lastRevisionId}, function (maxBounds) {\n                    if (minBounds.x < totalBounds.min[0]) {\n                      totalBounds.min[0] = minBounds.x;\n                    }\n                    if (minBounds.y < totalBounds.min[1]) {\n                      totalBounds.min[1] = minBounds.y;\n                    }\n                    if (minBounds.z < totalBounds.min[2]) {\n                      totalBounds.min[2] = minBounds.z;\n                    }\n                    if (maxBounds.x > totalBounds.max[0]) {\n                      totalBounds.max[0] = maxBounds.x;\n                    }\n                    if (maxBounds.y > totalBounds.max[1]) {\n                      totalBounds.max[1] = maxBounds.y;\n                    }\n                    if (maxBounds.z > totalBounds.max[2]) {\n                      totalBounds.max[2] = maxBounds.z;\n                    }\n                    nrProjects--;\n                    if (nrProjects === 0) {\n                      loadModels(models, totalBounds);\n                    }\n                  });\n                });\n              });\n            } else {\n              nrProjects--;\n              if (nrProjects === 0) {\n                loadModels(models, totalBounds);\n              }\n            }\n          });\n        });\n      });\n    });\n});\n```\n\n#### 效果展示\n\n在index.html中右击，选择 `Run 'index.html'`或者Ctrl + Shift + F10启动页面，效果如图：\n\n![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-hellobim-01.png)\n\n点击任意部件，部件高亮并且可以查看部件的信息。\n\n![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-hellobim-02.png)\n\n\n\n*界面丑，待优化，至少模型加载并展示了嘛*\n\n*能力有限，如有错误或疑问请在评论区指出，谢谢。*\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["BIM","BIMserver"],"categories":["languages"]},{"title":"BIMserver入门笔记 - 01环境搭建、数据导入及预览","url":"/posts/3869274485/","content":"**轻松搭建BIMserver开发环境：**\nBIMserver在国内开发资料太少，关于环境搭建的有一些，我也是参照着这些教程一步步的搭建，该笔记把遇到的一些坑给记录下来，方便以后参考。\n\n<!--more-->\n\n1. BIMserver入门笔记 - 01环境搭建、数据导入及预览\n\n2. [BIMserver入门笔记 - 02登录及模型展示](../3230248873/)\n\n现在的工作就是，什么热就干什么（什么... 小李你说啥，Tom热~~），这年头就这样，能把自己的产品给推出去，并且能加码推出去就是胜利。\n\nBIM在行业里应用不多，大家都在积极的储备该技术，都指望着自己能厚积薄发。\n\n### 软件下载\n\n这里给出官方开源[地址](https://github.com/opensourceBIM/BIMserver)，下载相应版本的发布版本（这里以[v1.5.88](https://github.com/opensourceBIM/BIMserver/releases/tag/parent-1.5.88)为例，下载资料已经整理好了，点击[下载](https://github.com/ibrucekong/bimserver-env)）。\n\n*由于BIMserver的开发环境搭建时对版本的兼容性要求比较高，小版本不一样都会出错*\n\n### 环境搭建\n\n1. 选择一个文件夹命名`BIMserver`，且整个文件夹的路径中没有空格和中文；\n\n2. 将`bimserver-env`文件夹下的文件都拷贝进来\n\n3. 双击`bimserverjar-1.5.88.jar`，`Address`内容改为`你的IP`，然后点击`Start`\n\n4. 等服务启动成功后，点击`Launch Webbrowser`，打开平台自带的运维界面\n\n   这是一个主要的配置过程，过程就用图片来说明了，如下：\n\n   a. 找一个没有中文、没有空格的路径，存放jar文件\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-01.png) \n\n   b. 全程使用IP作为服务发布的地址，先获取IP再说\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-02.png) \n\n   c. 双击启动jar，将Address中的localhost改为刚才获取的IP，点击右下角的start按钮\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-03.png) \n\n   d. 当看到信息窗口中打印 Server started successfully即可，并点击 Launch Webbrowser\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-04.png) \n\n   e. 打开BIMserver的运维安装界面，填写服务名称、服务描述，其他默认即可，点击Next\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-05.png) \n\n   f. 设置管理员账号、密码，进入下一步\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-06.png) \n\n   g. 设置email服务，忽略，点击Next\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-07.png) \n\n   h. 勾选掉所有的插件的勾，点击upload JAR files of plugins，进行离线安装插件\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-08.png) \n\n   i. 由于每次只能打开一个插件，所以需要耐心的将每一个插件选择好（不要有遗漏哦）\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-09.png) \n\n   j. 这是插件列表，最好数一下\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-10.png) \n\n   k. 默认，下一步\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-11.png) \n\n   l. 点击 Setup，开始安装\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-12.png) \n\n   m. 安装过程中，打印了一行红色的字体，忽略，不用管，会继续安装\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-13.png) \n\n   n. 直至出现以下内容，表示安装成功，点击箭头指向的链接\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-14.png) \n\n   o. 刷新后，出现这些内容，主要使用的是bimviews，点击打开\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-15.png) \n\n   p. 需要身份验证，填写安装时填写的账号、密码\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-16.png) \n\n   q. 登录成功后，界面中是工程列表，但是没有工程\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-17.png) \n\n   r. 找到如图的新建项目的按钮\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-18.png) \n\n   s. 输入项目名称、项目描述，其他默认，点击Add\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-19.png) \n\n   t. 项目创建成功，点击箭头所指的按钮\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-20.png) \n\n   u. 选择 Checkin... 进行模型的导入\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-21.png) \n\n   v. 导入模型有两种方式，一种是本地文件，一种是URL，这里以本地文件为例进行演示\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-22.png) \n\n   w. 选择需要导入的模型文件\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-23.png) \n\n   x. 选择好后，文件类型和注释都有默认值，直接点击Checkin new revision\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-24.png) \n\n   y. 这个导入速度和使用的电脑性能有关\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-25.png) \n\n   z. 导入成功后，点击3D这个按钮\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-26.png) \n\n   aa. 在左侧布局中，有可以展开的树结构，和有控制显隐的眼睛\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-27.png) \n\n   ab. 模型展示效果，左键拖拽旋转，中键拖拽平移\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-28.png) \n\n   ac. 通过隐藏外面的部件，可以看到内部的细节\n\n   ![](https://coding.net/u/ibrucekong/p/images/git/raw/master/bimserver-29.png) \n\n### 注意事项\n\n1. BIMserver的文件夹 [不要有中文，不要有空格]*3 （假设说了三次）\n2. 服务地址最好填写为IP（管他呢，写localhost也行，但是总感觉后面会需要改为IP或域名）\n3. 记住账号，密码\n4. 安装插件式需要科学上网的（就因为这个，博主专门为搭建准备了完备的安装包和离线文件）\n\n\n\n*能力有限，如有错误或疑问请在评论区指出，谢谢。*\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["BIM","BIMserver"],"categories":["languages"]},{"title":"前端地图应用中几种监听事件","url":"/posts/1380263657/","content":"**轻松绑定解除事件监听：**\n在前端使用JavaScript给一个元素绑定、解除监听事件最为常用的是addEventListener，解除也很容易。在前端地图开发中，也会遇到很多事件绑定、解除的问题，下面我们就来讨论一下在这些环境下的事件监听是怎么实现的。\n\n<!--more-->\n\n从事GIS方向，和地图打交道比较多，对于各种地图的监听事件的使用比较多，对于常用的事件监听方法梳理了以下内容，作为笔记保存。\n\n### 事件监听\n\n>  JavaScript使我们有能力创建动态页面，网页中的每一个元素都可以产生某些触发JavaScript函数的事件。我们可以认为事件是可以被JavaScript侦测到的一种行为。\n\n### 地图开发中的事件监听\n\n* 百度\n* 高德\n* 谷歌\n* ArcGIS\n\n### 事件监听的使用\n\n#### 原生事件监听\n\n在Web项目中要对dom元素绑定监听事件，有onclick，原生方法一般使用attachEvent和addEventListener。其中attachEvent使用与IE早期版本，比如IE6、7、8，而addEventListener适用于IE9、10、11，还有FireFox、Chrome、Safari和Opera等现代浏览器。\n\n1. 直接添加\n\n   a. html方式\n\n   ```html\n   <!-- 最简单的是在dom上添加 onclick 属性 -->\n   <input type=\"button\" value=\"clickMe\" onclick=\"check(this)\">\n   ```\n\n   b. javascript方式\n\n   ```javascript\n   // 给元素添加 onclick 事件 ： onclick还可以是 ondblclick、ondrag等\n   element.onclick = function(){\n       // logic\n   }\n   ```\n\n2. attachEvent\n\n   在早期IE中，使用attachEvent作为添加监听的一种方式，对一个元素绑定监听可以按照以下方式进行：\n\n   ```javascript\n   /**\n   * 绑定监听\n   * element 需要添加事件监听的元素或dom\n   * event 事件类型（事件名称），是字符类型，比如包含\"onclick\"、\"onmouseover\"、\"onkeyup\"等\n   * callback 触发监听的回调函数\n   */ \n   element.attachEvent(event, callback)；\n   \n   /**\n   * 移除监听\n   * element 需要移除事件监听的元素或dom\n   * event 事件类型（事件名称），是字符类型，比如包含\"onclick\"、\"onmouseover\"、\"onkeyup\"等\n   * callback 触发监听的回调函数\n   */ \n   element.attachEvent(event, callback)；\n   \n   /**\n   * callback 是回调函数名，可以自定义\n   * e 是回调参数\n   */\n   function callback(e){\n       // logic\n   }\n   ```\n\n3. addEventListener\n\n```javascript\n/**\n* 绑定监听\n* element 需要添加事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"click\"、\"mouseover\"、\"keyup\"等\n* callback 触发监听的回调函数\n*/ \nelement.addEventListener(event, callback)；\n\n/**\n* 移除监听\n* element 需要移除事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"click\"、\"mouseover\"、\"keyup\"等\n* callback 触发监听的回调函数\n*/ \nelement.removeEventListener(event, callback)；\n\n/**\n* callback 是回调函数名，可以自定义\n* e 是回调参数\n*/\nfunction callback(e){\n    // logic\n}\n```\n\n4. 小结\n\n从以上两个方法我们可以看出其中存在着一些差别：\n\n1. 兼容性方面，attachEvent仅支持早期的IE版本，而addEventListener支持的较为广泛；\n2. attachEvent在事件类型上，比addEventListener多一个字符\"on\"，需要额外注意；\n3. 两者绑定监听都需要实名函数，匿名函数的绑定关系是无法移除的。\n\n#### 百度事件监听\n\n在百度地图中对dom元素的监听，官方给出的是addEventListener和removeEventListener，使用方法和原生的addEventListener类似，但是地图API事件监听是独立的，与原生的dom事件不同，而且还增加很多自定义的事件类型。\n\n```javascript\n/**\n* 绑定监听\n* element 需要添加事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"click\"、\"mouseover\"、\"dragstart\"等\n* callback 触发监听的回调函数\n*/ \nelement.addEventListener(event, callback)；\n\n/**\n* 移除监听\n* element 需要移除事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"click\"、\"mouseover\"、\"dragstart\"等\n* callback 触发监听的回调函数\n*/ \nelement.removeEventListener(event, callback)；\n\n/**\n* callback 是回调函数名，可以自定义\n* e 是回调参数\n*/\nfunction callback(e){\n    // logic\n}\n```\n\n需要注意的是，如果要能解绑事件，绑定监听时就需要使用实名函数，匿名函数是无法解绑的。\n\n#### 高德事件监听\n\n高德在事件监听上提供了众多的方法，使用最多的就是on/off组合，另外还有addDomListener、addListener、addListenerOnce、removeListener和trigger，此次主要介绍一下最为常用的使用方法。\n\n```javascript\n/**\n* 绑定监听\n* element 需要添加事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"click\"、\"mouseover\"、\"dragstart\"等\n* callback 触发监听的回调函数\n*/ \nelement.on(event, callback)；\n\n/**\n* 移除监听\n* element 需要移除事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"click\"、\"mouseover\"、\"dragstart\"等\n* callback 触发监听的回调函数\n*/ \nelement.off(event, callback)；\n\n/**\n* callback 是回调函数名，可以自定义\n* e 是回调参数\n*/\nfunction callback(e){\n    // logic\n}\n```\n\n同样的，在 绑定和解绑时都应该使用实名函数，除非之后不需要解绑。\n\n#### 谷歌事件监听\n\n```javascript\n/**\n* 绑定监听\n* element 需要添加事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"click\"、\"mouseover\"、\"dragstart\"等\n* callback 触发监听的回调函数\n*/ \nvar evt = google.maps.event.addListener(event, callback)；\n\n/**\n* 移除监听\n* element 需要移除事件监听的元素或dom\n* evt 绑定监听时的句柄\n*/ \ngoogle.maps.event.removeListener(evt)；\n\n/**\n* callback 是回调函数名，可以自定义\n* e 是回调参数\n*/\nfunction callback(e){\n    // logic\n}\n```\n\n到谷歌这里，绑定监听就不如百度和高德那样，而是通过绑定监听返回的句柄进行解绑操作。这样的话，在绑定监听时的回调函数就可以是匿名函数，也可以是实名函数了。所以说上帝为你关闭的一扇大门，肯定会给你打开一扇窗户，不会让你为难的。\n\n#### ArcGIS中的事件监听\n\nArcGIS的事件监听有两种方式，一种是很早之前的版本connect style，一种是on style。其中connect是通过dojo进行实现，不过现在更加推荐on来实现。\n\n1. connect style\n\n```javascript\n/**\n* 绑定监听\n* element 需要添加事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"onClick\"、\"onMouseOver\"等\n* callback 触发监听的回调函数\n*/ \nvar evt = dojo.connect(element, event, callback)；\n\n/**\n* 移除监听\n* evt 绑定监听时的句柄\n*/ \ndojo.disconnect(evt)；\n\n/**\n* callback 是回调函数名，可以自定义\n* e 是回调参数\n*/\nfunction callback(e){\n    // logic\n}\n```\n\n2. on style\n\n```javascript\n/**\n* 绑定监听\n* element 需要添加事件监听的元素或dom\n* event 事件类型（事件名称），是字符类型，比如包含\"click\"、\"mouse-over\"等\n* function 触发监听的回调函数\n*/ \nvar evt = element.on(event, callback)；\n\n/**\n* 移除监听\n* element 需要移除事件监听的元素或dom\n* evt 绑定监听时的句柄\n*/ \nevt.remove()；\n\n/**\n* callback 是回调函数名，可以自定义\n* e 是回调参数\n*/\nfunction callback(e){\n    // logic\n}\n```\n\n其中connect style和on style对于event格式不一样，除了方法名不一样外，在调用方面也存在一定的不同，需要额外注意，不要混淆。\n\n### 事件监听总结\n\n从上到下看过来，就会发现事件监听也是大同小异，调用方式、事件名称都是次要，关键是考虑好事件绑定后要不要解除，一般来讲都需要绑定实名函数（也有例外，比如谷歌和ArcGIS），方便解除监听事件。\n\n从事开发行业，特别是GIS行业，几乎在所有的项目中都会使用事件监听（主要指地图事件监听），所以希望小伙伴都能扎实的掌握好该技能。\n\n\n\n*能力有限，如有错误或疑问请在评论区指出，谢谢。*\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["事件监听"],"categories":["languages"]},{"title":"IE和Chrome带有多个参数的互相跳转","url":"/posts/1077207737/","content":"**IE & Chrome的互相跳转：**\n简单需求，简单实现。从IE跳转到Chrome，介绍使用`ActiveXObject`进行操作跳转，并实现多个参数的传递；从Chrome跳转到IE，介绍使用修改注册表的形式进行操作。\n\n<!--more-->\n\n### IE to Chrome\n\n在IE中打开Chrome方法简单且粗暴，`talk is cheap, show me the code`。\n\n#### 单参or无参\n\n```\nvar objShell = new ActiveXObject(\"WScript.Shell\");\n// 无参\nobjShell.Run(\"cmd.exe /c start chrome www.baidu.com\",0,true);\n```\n\n![无参](https://coding.net/u/ibrucekong/p/images/git/raw/master/ie-to-chrome-no-param.png)\n\n```\nvar objShell = new ActiveXObject(\"WScript.Shell\");\n// 单参\nobjShell.Run(\"cmd.exe /c start chrome www.baidu.com?id=1\",0,true);\n```\n\n\n\n![单参](https://coding.net/u/ibrucekong/p/images/git/raw/master/ie-to-chrome-one-param.png)\n\n上述情况都没问题，一切都很顺利，下面来看看多参的情况。\n\n#### 多参传递\n\n```\n// 如果要传 id=1, name=bruce 两个参数\nvar objShell = new ActiveXObject(\"WScript.Shell\");\nobjShell.Run(\"cmd.exe /c start chrome www.baidu.com?id=1&name=bruce\",0,true); \n```\n\n![多参](https://coding.net/u/ibrucekong/p/images/git/raw/master/ie-to-chrome-one-param.png)\n\n什么鬼，我明明传了两个参数啊，怎么只显示了一个，只显示了第一个。What the hell is going on?\n\n原来在cmd的世界里，它有自己的一套转义语法，可参考[链接](https://www.cnblogs.com/newsea/p/3866413.html)。\n\n```\nvar objShell = new ActiveXObject(\"WScript.Shell\");\n// 经过修正，将&符号进行转义，使用^&代替&\nobjShell.Run(\"cmd.exe /c start chrome www.baidu.com?id=1^&name=bruce\",0,true); \n```\n\n![多参](https://coding.net/u/ibrucekong/p/images/git/raw/master/ie-to-chrome-more-param.png)\n\n看完在IE中打开Chrome了，现在来瞅瞅在Chrome中打开IE的方法吧。\n\n### Chrome to IE\n\n在Chrome中打开IE，并传多参数，相比IE中打开Chrome要麻烦一些，大致分为以下几个方面。\n\n#### 配置跳转环境\n\n1. regOpenIE.reg\n\n   1.1 在D盘下新建openIE文件夹，路径为`D:\\openIE\\`\n\n   1.2 在openIE路径下新建`regOpenIE.reg`，并将如下内容复制进该文件：\n\n```\nWindows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\openIE]\n@=\"URL:Alert Protocol\"\n\"URL Protocol\"=\"\"\n\n[HKEY_CLASSES_ROOT\\openIE\\DefaultIcon]\n@=\"iexplore.exe,1\"\n\n[HKEY_CLASSES_ROOT\\openIE\\shell]\n\n[HKEY_CLASSES_ROOT\\openIE\\shell\\open]\n\n[HKEY_CLASSES_ROOT\\openIE\\shell\\open\\command]\n@=\"cmd /c set m=%1 & \\\"D:\\\\alert\\\\openIE.bat\\\" %%m%% & exit\"\n```\n\n其中文本中的最后一行`D:\\\\alert\\\\openIE.bat\\`是当前文件的目录。\n\n2. 在openIE文件夹下新建`openIE.bat`，并将如下内容复制进该文件：\n\n```\n@echo off\nset m=%m:openIE:=%\nset m=\"%m:separator=&%\"\nstart \"\" \"C:\\\\Program Files\\\\internet explorer\\\\iexplore.exe\" %m%\nexit\n```\n\n其中文本中`start`一行中`C:\\\\Program Files\\\\internet explorer\\\\iexplore.exe`是你电脑中IE的路径，注意分隔符是双反斜杠。\n\n#### 单参or无参\n\n1. 在布局中加入以下内容。\n\n```\n<a href=\"openIE:www.baidu.com\">Chrome to IE</a>\n```\n\n![无参](https://coding.net/u/ibrucekong/p/images/git/raw/master/chrome-to-ie-no-param.png)\n\n```\n<a href=\"openIE:www.baidu.com?id=1\">Chrome to IE</a>\n```\n\n![单参](https://coding.net/u/ibrucekong/p/images/git/raw/master/chrome-to-ie-one-param.png)\n\n\n\n#### 多参传递\n\n```\n// 和测试IE跳转Chrome一样，传 id=1, name=bruce 两个参数，看下效果是不是能出来\n<a href=\"openIE:www.baidu.com?id=1&name=bruce\">Chrome to IE</a>\n```\n\n![多参](https://coding.net/u/ibrucekong/p/images/git/raw/master/chrome-to-ie-one-param.png)\n\n同样的思维，是不是`&`又被转义或者影响到了呢，查阅资料，有[博主](https://blog.csdn.net/java_zys/article/details/51837899)给出了一个解决方案，使用无转义的字符去替代的方案(就是上面`openIE.bat`中第三行给出的内容)。\n\n```\n<a href=\"openIE:www.baidu.com?id=1separatorname=bruce\">Chrome to IE</a>\n```\n\n![多参](https://coding.net/u/ibrucekong/p/images/git/raw/master/chrome-to-ie-more-param.png)\n\n使用参数中的`separator`代替`&`，完成解析。\n\n### 写在最后\n\nIE和Chrome的跳转可能还有其他方法，如果朋友找到更加简单的方法，请在下面回复告诉博主，感激不尽。\n\n\n\n<div style=\"text-align: center\"><img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["IE","Chrome","跳转"],"categories":["languages"]},{"title":"在Chrome中调试Ionic的Android应用","url":"/posts/289005530/","content":"**Ionic的Android端调试：**\n在以往Android原生开发时，App的调试用真机很是简单，即便是虚拟机调试，也是手到擒来；而如今，在混合应用横行的年代，动不动就是React-Native、Ionic、Vue、MUI等一系列的混合架构写出来的Android，还没对其调试过，公司采用Ionic研发并遇到一些坑，特将调试过程记录下来。\n\n<!--more-->\n\n首先百度一番，度娘告知有以下两种方法进行调试：\n\n1. 在项目根目录执行以下命令，调试信息将在console中打印出来\n\n   ````\n   ionic run android -l -c\n   ````\n\n2. Chrome调试\n\n由于是从项目中拿到App对其调试，没有工程，所以第一种调试方法无法测试。\n\n第二种方法是网上应用最多的，我们来看看需要哪些操作：\n\n1. 首先真机或虚拟机连接电脑（手机开USB调试模式，并且允许电脑能访问手机），并且在命令行中确认\n\n   ```\n   $ adb devices\n   ```\n\n   确保设备连接到电脑。\n\n2. 在Chrome中打开`chrome://inspect/#devices`，可以在Remote Target中看到已经连接的手机和手机中已经开启的应用线程。\n\n3. 找到需要调试的App，点击旁边的inspect（注意：电脑要能科学上网下载一些依赖，不然会显示404或一片空白，这些依赖会缓存下来，不清理缓存的话只需第一次运行时翻墙即可）\n\n4. 最重要的一点是，Ionic打的包一定是debug包，否则在Remote Target中是看不到该应用的，也就无法调试咯。\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>\n","tags":["Chrome","Ionic","Android","调试"],"categories":["languages"]},{"title":"入坑公路车","url":"/posts/1652333246/","content":"**第一辆公路车：**\n公路车第一次长草是在过了年的时候，以前也经常骑自行车，从小学三年级骑到大四毕业，车子就是很平常的平把山地车或者休闲车，对于小弯把公路车还真没接触过，这草说长就是疯长啊，果断收割。\n\n<!--more-->\n\n草已经长了快半年了，在网上也刷了不少相关的帖子，一直没忍心入坑。顾虑有以下两点：\n\n1. 买了主要通勤用，家里可以放心，停在公司真的是不放心；\n2. 平时练腿，健身健体，由于搬砖的工作性质，需要适当调节一下运动时间。\n\n就在昨天，小伙伴们已经购买了属于自己的拉轰电动，我也是差一点没忍住，当时三个人，但是电驴的配色只有两辆了，配色不够，我就“大方的”把机会让给他们俩了，更进一步的为我入坑公路车提供了绝佳的机会。\n\n今天在另一个朋友的陪同下，来到“XX捷安特专卖店”。之前在网上也浏览过一些博客、帖子，针对捷安特的公路车也了解了一些，但是真到了专卖店里，和老板攀谈起来还是有些切啊。\n\n由于预算（穷）的原因，心里只存放了SCR1、SCR2。首先，试骑了SCR2，此车入门偏下档次，就不再贴太多相关信息，骑了一圈就pass了；试骑SCR1，也是入门车，比SCR2贵1000钢镚，试骑比较了确实不一样，车架轻（前叉是碳纤维）而且稍有推背感（七哥说的，也确实是），最后选择了这款的原因有以下几点（又要吃土了）：\n\n1. 车比较轻，前叉是碳纤维，有效降低车头重量，并且提高刚性和吸震性；\n2. 涂装也比较喜欢，SCR2是黑白，SCR1有亮绿和消光亮黑，选择了后者；\n3. 没有螳螂须，内走线，逼格再次提升；\n4. 车架由GIANT 自家的ALUXX SL铝材，有效降低了整车重量。\n\n由于对公路车还不够了解，有些优缺点还需要继续发掘。\n\n配置详细信息如下：\n\n| 描述     | 型号                   |\n| -------- | ---------------------- |\n| 车架     | GIANT ALUXX SL         |\n| 前叉     | 碳纤维公路前叉         |\n| 撤吧     | 铝合金管公路把         |\n| 车首竖杆 | 铝合金竖杆             |\n| 座垫     | GIANT CONTACT 座垫     |\n| 座垫杆   | 铝合金 D 型座垫杆      |\n| 变速把手 | SHIMANO ST-R3000       |\n| 前变速器 | SHIMANO FD-R3000       |\n| 后变速器 | SHIMANO RD-R3000       |\n| 飞轮     | SHIMANO CS-HG400-9     |\n| 刹车     | SHIMANO BR-R3000       |\n| 大齿盘   | 铝合金中空一体齿盘     |\n| 轮圈     | 铝合金高框圈           |\n| 花鼓     | 铝合金培林花鼓         |\n| 钢丝     | HTSS 钢丝              |\n| 轮胎     | GIANT S-R4 700X25C轮胎 |\n| 后避震器 | 无                     |\n| SIZE     | S码 700CX445           |\n\n入门级别的公路车，已经很满意了，毕竟花了那么多大洋，未来几个月要吃土了。\n\n此处就不一一贴局部细节图了，只贴一些低像素的整车效果图：\n\n![Giant SCR1](https://coding.net/u/ibrucekong/p/images/git/raw/master/bike.png)\n\n*车子有了，还差很多装备，骑行服、锁踏、锁鞋、心率计、功率计等等，试问：我需要吗？*\n\n另外说下我的计划（这就是浪的理由？）：\n\n1. 平时保证通勤；\n2. 要有骑行计划，练踏频，练力量，健身咯；\n3. 这就是个附带效果了，争取三个月能减些脂肪，体重降2.5Kg；\n4. 有可能的话，最好能跟队骑行。\n\n看似简单的想法，但需要十足长期的努力，坚持很重要，加油！\n\n\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["自行车","公路车"],"categories":["bike"]},{"title":"Ionic使用百度地图弹窗并响应点击事件","url":"/posts/2994729501/","content":"**Ionic响应百度地图弹窗中的点击事件：**\nIonic使用的语法TypeScript，有一套自己的生命周期，和ES5之前的使用习惯不相同，变量作用域不尽相同。在Ionic中使用百度地图，也会踩一些坑，最近在业务中遇到了这样的需求，百度地图弹窗中动态写的HTML布局的响应事件无法拿到。\n\n<!--more-->\n\n### 在Ionic中使用百度地图\n\n#### 初始化地图\n\n```\n// 1.首先在index.html中引入百度地图的URL（其中要有申请的KEY）\n// <script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=3.0&ak=您的密钥\"></script>\n\n// 2.新建map组件，在ts文件中输入以下内容\nionViewWillEnter(){\n    let map = new BMap.Map(\"allmap\");// allmap是在html布局中定义的<div id=\"allmap\"></div>\n    let point = new BMap.Point(116.417, 39.921);// 初始化地图\n    map.centerAndZoom(point, 15);// 初始化地图视图\n}\n```\n\n#### 添加Marker\n\n```\n// 3.在 map.centerAndZoom(point, 15) 的下一行继续添加以下内容\nlet marker = new BMap.Marker(point);// 初始化Marker对象\nmap.addOverlay(marker);// 将marker放置到地图上\n```\n\n#### 为marker添加点击事件\n\n```\n// 4.在 map.addOverlay(marker) 的下一行继续添加以下内容\nmarker.addEventListener(\"click\", function(){\n    // TODO 做其他事情\n});\n```\n\n#### 弹出信息窗\n\n```\n// 5.在 map.addOverlay(marker) 和 marker.addEventListener 之间插入以下内容\nlet options = {\n    width: 200,\n    height: 100,\n    title: \"测试弹窗的标题\"\n}; // 定义弹出窗参数\nlet htm = '<div>内容：这是内容主体</div><div><button id=\"confirm\" onclick=\"test()\">确定</button></div>';\nlet infoWindow = new BMap.InfoWindow(htm, options); // 初始化弹出窗对象\n\n// 6.在 TODO 下面继续添加以下内容\nmap.openInfoWindow(infoWindow, point); // 点击marker执行该行代码，弹出信息窗\n\n// 7.在该ts文件中，添加test方法\ntest(){\n    console.log(\"如果我再控制台中打印出来，说明弹窗中的button响应了，反之。\");\n}\n```\n\n#### 控制台没打印\n\n打印失败了！！！\n\n有人分析说，`test`需要用`this`来调用，写成这个样子\n\n```\nlet infoWindow = new BMap.InfoWindow('<div>内容：这是内容主体，啦啦啦</div><div><button id=\"confirm\" onclick=\"this.test()\">确定</button></div>', options); // 初始化弹出窗对象\n```\n\n同样的，还是失败了。\n\n分析原因，是Ionic在初始化页面时，弹窗的布局信息并没有跟着初始化，而绑定的`test()`方法也没有初始化，所以绑定的方法无效。\n\n#### 解决方法\n\n那怎么样才能保证能将`test()`方法绑定到`button`上的呢？\n\n其实，我们可以曲线救国，让绑定事件在初始化弹窗之后，弹窗之前绑定，这样既可以有效的防止页面初始化带来的影响，又可以顺利绑定事件，下面是我的做法：\n\n```\n// 以上完整代码\n// 1.首先在index.html中引入百度地图的URL（其中要有申请的KEY）\n// <script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=3.0&ak=您的密钥\"></script>\n\n// 2.新建map组件，在ts文件中输入以下内容\nionViewWillEnter(){\n    let map = new BMap.Map(\"allmap\");// allmap是在html布局中定义的<div id=\"allmap\"></div>\n    let point = new BMap.Point(116.417, 39.921);// 初始化地图\n    map.centerAndZoom(point, 15);// 初始化地图视图\n    \n    // 3.在 map.centerAndZoom(point, 15) 的下一行继续添加以下内容\n    let marker = new BMap.Marker(point);// 初始化Marker对象\n    map.addOverlay(marker);// 将marker放置到地图上\n    \n    // 5.在 map.addOverlay(marker) 和 marker.addEventListener 之间插入以下内容\n    let options = {\n        width: 200,\n        height: 100,\n        title: \"测试弹窗的标题\"\n    }; // 定义弹出窗参数\n    let htm = '<div>内容：这是内容主体</div><div><button id=\"confirm\">确定</button></div>';\n    let infoWindow = new BMap.InfoWindow(htm, options); // 初始化弹出窗对象\n\n    // 4.在 map.addOverlay(marker) 的下一行继续添加以下内容\n    let that = this;\n    marker.addEventListener(\"click\", function(){\n        // TODO 做其他事情\n        // 绑定监听事件\n        document.getElementById(\"confirm\").onclick = that.test;\n        map.openInfoWindow(infoWindow, point); // 点击marker执行该行代码，弹出信息窗\n    });\n}\n\n// 7.在该ts文件中，添加test方法\ntest(){\n    console.log(\"如果我再控制台中打印出来，说明弹窗中的button响应了，反之。\");\n}\n```\n\n这样子再测试的话，控制台中就可以打印`如果我再控制台中打印出来，说明弹窗中的button响应了，反之。`\n\n### 总结\n\n以上问题在常规的B/S项目中不会发生，这是因为在Ionic项目中，使用的是Angular语法，即TypeScript（JavaScript的超集），该语法自己定义了一些新特性，使得开发效率更高，语法更简洁，再加上ES6（或更高）新特性，使得在动态生成的页面上绑定监听事件失效，所以可以通过延迟绑定或者适当时机绑定来解决。\n\nIonic做项目和以往的ES5或原生项目相比，效率更高、兼容多平台、开源组件更多、也更加美观，是一个比较好的路子。\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>\n","tags":["Ionic","百度地图","点击事件"],"categories":["languages"]},{"title":"吾爱破解论坛2018年7月21日暑假开放注册通知","url":"/posts/2639421812/","content":"**吾爱破解论坛注册喜讯：**\n吾爱开放注册又来了，此次是2018年第二次开放注册，3月13日没能上车的小伙伴，这次正值周六，天时地利人和，要整理好自己的注册资料，期待21日的到来吧。\n\n<!--more-->\n\n<div style=\"text-align: center;font-weight: bold;font-size: 2rem; color: red\">\n\t喜讯、喜讯、喜讯\n</div><div style=\"text-align: center;font-weight: bold;font-size: 1.5rem\">\n\t<span>吾爱破解论坛开通开放注册</span>\n\t<span>2018年7月21日12:00-14:00和20:00-22:00</span>\n</div><div style=\"text-align: center;font-weight: bold;font-size: 1.5rem;padding-top: 0;margin-top: 0;height: 106px;line-height: 106px\"><a href=\"https://www.52pojie.cn/?fromuid=575811\" style=\"text-align: center;\">我要吾爱</a></div>\n<div></div>\n***注册注意事项：***\n\n1. 吸取上次上车失败的教训！！！\n2. 注意不要错过注册时间\n3. 认真读注册须知（需要等10分钟）\n4. 事先把注册信息写在本子或word里（独一无二的邮箱和用户名） [需要准备什么](https://www.52pojie.cn/misc.php?mod=faq&action=faq&id=15&messageid=16)\n5. 耐心检查填写内容（看是否都符合要求）\n6. 邮箱验证阶段，有的要到邮箱的垃圾箱中查看有没有验证邮件，而有的邮箱则需要设置白名单才能收到验证邮件 [帮助](https://www.52pojie.cn/thread-98585-1-1.html)\n\n<div style=\"text-align: center;font-weight: bold;font-size: 1.5rem\">\n\t祝愿小伙伴们都能获得自己的吾爱账号！\n</div><div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["活动","吾爱破解"],"categories":["tips"]},{"title":"在Linux中解决跨网段访问服务","url":"/posts/3249349784/","content":"**在Linux中解决跨网段访问服务：**\n有这样一个场景：在局域网中，两台电脑，A电脑使用交换机（192.168.72.33），B电脑使用WiFi（192.168.1.21），两者的网段不同，导致电脑A无法ping通电脑B。今天就来讲讲怎么在Linux中解决这个问题。\n\n<!--more-->\n\n这是我在生产环境中遇到的一个问题，刚开始接触，踩了不小的坑，耽误了很长时间，以此来记录一下。\n\n针对以上问题的解决办法就是：添加一个路由！\n\n在A电脑中打开终端\n```\n$ route add default gw 192.168.72.1\n```\n加上后，发现可以ping通了，但是重启机器后，又无法ping通了。原因是上面加的路由是临时的，并未在系统中永久保存，如果需要添加永久路由，按照以下方法：\n* 打开终端，执行：\n```\n$ vi /etc/rc.local\n```\n* 在文档后插入一行，输入*route add default gw 192.168.72.1*\n* 按ESC键退出编辑状态，输入`:wq`，回车保存即可。\n\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>\n","tags":["Linux","Route"],"categories":["tools"]},{"title":"在Linux中如何使用SCP快速拷贝数据","url":"/posts/1224017506/","content":"**在Linux中快速拷贝数据的工具：**\n\n根据工作上的需求：一个场景，两台电脑，万千碎片数据，该怎么从A电脑拷贝这些数据到B电脑？直接复制、粘贴？先打包、再复制粘贴？方法有很多，但是很少人去分析拷贝数据的快慢。\n\n<!--more-->\n\n上面说的问题，在Linux、Windows、Mac环境下都存在，这里只从Linux的角度来实现下。为什么呢？不知大家注意上面“万千碎片数据”字眼了吗，一般这样的字眼基本上会出现在服务器的存储中，而当今服务器使用最多的操作系统就是Linux，所以本文只针对Linux之间互传为例进行说明。\n\n## SCP是什么\n\nscp是secure copy的简写，用于Linux下进行远程拷贝的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的（稍微会影响一点速度）。\n\n## 为什么要用SCP\n\n1. 如果服务器上没有配置FTP服务器，没有开启web服务器，也没有做共享，无法通过常规的途径获取文件时，可以考虑使用scp。\n2. 需要将本机文件上传至远程服务器上，远程服务器没有开启FTP服务器或共享，无法通过常规方法上传时，可以考虑scp。\n\n## 场景简介\n\n假设以下两台电脑是通过公网连接的，只需要把局域网的IP换成公网的IP即可。\n\n| 字段     | A电脑          | B电脑                 |\n| -------- | -------------- | --------------------- |\n| 场景     | CentOS6.5      | Ubuntu16.04           |\n| 用户名   | root           | bruce                 |\n| IP       | 192.168.1.20   | 192.168.1.21          |\n| 数据目录 | /home/backups/ | /media/bruce/backups/ |\n| 文件     | 某些png图片    | 某些png图片           |\n\n## 参数介绍\n\n| 命令参数 |                                                          |\n| ------------------- | ------------------------------------------------------------ |\n| -1                | 强制scp命令使用协议ssh1                                      |\n| -2                | 强制scp命令使用协议ssh2                                      |\n| -4                | 强制scp命令只使用IPv4寻址                                    |\n| -6                | 强制scp命令只使用IPv6寻址                                    |\n| -B                | 使用批处理模式（传输过程中不询问传输口令或短语）             |\n| -C                | 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）            |\n| -p                | 保留原文件的修改时间，访问时间和访问权限。                   |\n| -q                | 不显示传输进度条。                                           |\n| -r                | 递归复制整个目录。                                           |\n| -v                | 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 |\n| -c cipher         | 以cipher将数据传输进行加密，这个选项将直接传递给ssh。        |\n| -F config     | 指定一个替代的ssh_config配置文件，此参数直接传递给ssh。   |\n| -i file  | 从identity_file指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 |\n| -l limit          | 限定用户所能使用的带宽，以Kbit/s为单位。                     |\n| -o option     | 如果习惯于使用ssh_config(5)中的参数传递方式。                |\n| -P port           | 注意是大写的P, port是指定数据传输用到的端口号。              |\n| -S program        | 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 |\n\n\n\n## 数据传输\n\n1. 获取服务器上文件\n\n```\nscp root@192.168.1.20:/home/backups/1.png /media/bruce/backups/1.png\n```\n按回车键：\n\n如果是第一次试用scp，会提示是否使用传输，输入yes，回车；\n\n然后接着提示输入root用户的密码（输入密码时是看不到字符出现的，输入好直接回车）\n\n2. 获取服务器上的目录\n\n```\nscp -r root@192.168.1.20:/home/backups/ /media/bruce/backups/\n```\n3. 将本地文件上传至服务器\n\n```\nscp /media/bruce/backups/2.png root@192.168.1.20:/home/backups/2.png\n```\n\n4. 将本地目录上传至服务器\n\n```\nscp -r /media/bruce/backups/ root@192.168.1.20:/home/backups/\n```\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>\n","tags":["SCP","Linux"],"categories":["tools"]},{"title":"从零开始搭建自己的博客天地(下)","url":"/posts/3337762157/","content":"**建站，重在折腾：**\n\n在建站这个系列中，上一篇主要讲了怎么搭建博客环境，初始化博客项目，怎么新增博文，以及怎么部署博客。本次主要讲解一下`config.yml`文件，怎么巧妙的使用`HTTPS`的图床，还有就是听起来高大尚的**绑定域名**。\n\n<!--more-->\n\n上次在《从零开始搭建自己的博客天地(上)》中讲过Coding建站的文章，时隔那么久，估计很多小伙伴都遗忘了，这里提供了上篇文章的[链接](https://blog.brucekong.com/posts/3667539278/)，或者使用站内搜索功能 [Ctrl+F]：从零开始搭建自己的博客天地(上) ，阅读上篇之后再读此篇效果更好。\n\n## 解析config.yml文件\n\n关于其中的参数，大家可以参照官网提供的教程（[中文](https://hexo.io/zh-cn/docs/configuration.html)、[English](https://hexo.io/docs/configuration.html)）\n一般来讲，需要大家修改以下参数：\n\n| 参数        | 描述                                                  |\n| :---------- | :----------------------------------------------------------- |\n| title       | 这个是你网站的标题                                   |\n| subtitle    | 这个是你网站的副标题                                 |\n| description | 这个是你网站的描述信息                              |\n| author      | 这个是你的名称                                                    |\n| url         | 这个是你网站的地址                                      |\n| theme       | 这个是你引用哪个博客主题，设置为false表示不使用主题                         |\n| deploy      | 这个是你想把博客部署到哪个托管平台上                                          |\n\n## 使用图床管理博文图片\n当前使用比较多的图床系统包括七牛、又拍云、新浪、极简图床，其中七牛和又拍云是收费图床，后面两个是免费的，知乎大佬都给过说明，好与坏戳[我](https://www.zhihu.com/question/21667151/answer/74657827)。\n\n图床是有了，但是支不支持HTTPS又是另一回事，关于这个问题，放给大家去研究，这里不再细说。\n\n当然对于小白（比如我）来说，使用Coding仓库作为图床也是不错的，而且还支持HTTPS，但是唯一的缺点就是速度太慢了。\n\n使用Coding方法：\n\n* 在Coding中新建一个仓库，例如叫images；\n* clone仓库到本地，将图片添加到仓库，并push到Coding；\n* 打开网页端的images仓库，点击需要的使用的图片，得到链接（url）；\n* 将url中的blob改成raw即可使用。\n\n这个方法不推荐使用，有条件的还是使用七牛，毕竟速度还是有保障的。\n\n\n\n## 域名使用\n\n为了让自己的博客显得更高大尚的话，可以将自己的博客绑定自己的域名。\n\n在个人博客中使用域名，首先要购买一个域名，域名根据不同的组合，价格不一样，当然也有免费的。根据个人使用经验，不建议使用免费的，常言道：免费的既是最贵的。因为在大多数情况下，域名就代表了你的博客，但是大部分免费域名只是免费一年，之后是需要购买的，域名到期后，很多人都觉得不值得续费，但是又有很多信息都是绑定的这个域名，从而陷入两难的境地。所以我建议大家好好考虑，尽量购买一个自己中意的，能长期使用的域名。\n\n罗里吧嗦了那么多，小编总结了以下几点：\n\n* 一定是自己中意的，并能保证持续使用的\n\n\n* 尽量购买`com`、`net`、`site`、`cc`、`top`、`club`等一级域名作为博客域名\n* 域名越短越好\n* 尽量只使用字母或数字\n* 域名能有一定的含义或容易记住\n\n小编是在阿里云上购买的域名，那小编就讲述一下自己是怎么将自己的域名绑定到自己的博客上的。\n\n* 首先，登陆阿里云官网，注册账号并登陆，并在[万网](https://wanwang.aliyun.com/)上购买自己心仪的域名\n* 然后，打开“控制台”（右上角处），在左侧列表中找到倒数第二行“域名与网站”，点击“云解析DNS”\n* 在右侧看到购买的域名，点击“解析设置”\n* 为确保成功，先删除所有的解析设置\n* 点击右上角的”添加解析“，记录类型选择”CNAME“，主机记录填入”@“，解析路线默认即可，记录值填入\"demo.coding.me\"，确认即可。\n\n**注意：以上的所填内容，只填引号内部的**\n\n到此，稍等半小时，等待解析设置生效。\n\n\n\n然后去设置Coding中博客：\n\n* 在`博客根目录/source`下新建一个CNAME文本，输入你的域名（例如demo.com），push到Coding中\n* 打开`https://coding.net/u/demo/p/demo.coding.me/git/pages/static`，在“自定义域名”处绑定自己的域名即可。\n\n\n\n稍等片刻，在浏览器中打开你的域名（demo.com），不出意外就能解析到你的博客了。\n\n\n\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Hexo","Blog"],"categories":["tips"]},{"title":"使用Nginx和OpenSSL搭建本地HTTPS的ArcGIS for JavaScript 4.6","url":"/posts/2692255794/","content":"**HTTPS的初试：**\n前两天看谷歌开发者公众号了解到Google Chrome要在68这个版本时彻底将HTTP网站列为不安全，要求全部网站都要支持HTTPS，由此萌生了先在本地搭建一些HTTPS的站点的想法。\n\n<!--more-->\n\n## 1 背景\n由于工作任务，最近一直在写本子，了解了一些GIS方面的小知识，但是学的很浅显，其中就包括ArcGIS for JavaScript。基于谷歌公众号里面的启发，就想着在本地搭建一个HTTPS结构的ArcGIS for JavaScript站点。\n\n## 2 准备工作\n* Nginx [下载](http://nginx.org/en/download.html)\n* OpenSSL [下载](http://down-www.7down.net/pcdown/soft/W/win64openssl.rar)\n* ArcGIS for JavaScript 4.6 [下载](https://developers.arcgis.com/downloads/apis-and-sdks?product=javascript&version=4.6)\n\n***注意：下载ArcGIS for JavaScript前，先在[https://developers.arcgis.com](https://developers.arcgis.com)注册ArcGIS账号***\n\n## 3 安装配置\n### 3.1 Nginx\n下载好Nginx后，解压到`C:\\`，得到`nginx.exe`在`C:\\nginx\\`根目录下，并将`C:\\nginx`添加到系统环境变量的`PATH`中，即可完成Nginx的安装和配置。\n\n### 3.2 OpenSSL\n下载好OpenSSL后，双击安装，将安装目录设置为`C:\\`中，安装后即为`C:\\OpenSSL-Win64`，同理将`C:\\OpenSSL-Win64\\bin`添加到系统环境变量的`PATH`中，即可完成Nginx的安装和配置。\n\n### 3.3 ArcGIS for JavaScript 4.6\n下载好ArcGIS for JavaScript 4.6后，解压到`C:\\nginx\\html\\`中，得到一个`C:\\nginx\\html\\arcgis_js_api\\library\\4.6\\`类似的目录。和往常一样，需要修改`init.js`和`dojo.js`中的域名信息。\n\n将init.js和dojo.js中的以下的信息：\n```\nbaseUrl:\"https://[HOSTNAME_AND_PATH_TO_JSAPI]dojo\"\n```\n修改为：\n```\nbaseUrl:\"http://localhost/arcgis_js_api/library/4.6/dojo\"\n\nor\n\nbaseUrl:\"https://localhost/arcgis_js_api/library/4.6/dojo\"\n```\n** 注意：~~将https改为http~~  这里不改也是可以的 **\n\n自此，安装配置即已经完成，下一步需要生成并在Nginx中配置证书。\n\n## 4 证书的生成与配置\n\n### 4.1生成证书\n\n在网上查资料，有大佬是这样子做的（先不要照抄这里，继续看下面的）：\n\n```\n$ openssl req -x509 -newkey rsa:2048 -out LocalhostCA.cer -outform PEM -keyout LocalhostCA.pvk -days 10000 -verbose -config LocalhostCA.cnf -nodes -sha256 -subj \"/CN=localhost CA\"\n\n$ openssl req -newkey rsa:2048 -keyout Localhost.pvk -out Localhost.req -subj /CN=localhost -sha256 -nodes\n\n$ openssl x509 -req -CA LocalhostCA.cer -CAkey LocalhostCA.pvk -in Localhost.req -out Localhost.cer -days 10000 -extfile Localhost.ext -sha256 -set_serial 0x1111\n```\n\n首先在`C:\\OpenSSL-Win64\\bin`新建两个文件：\n第一个文件`LocalhostCA.cnf`:\n```\n[ req ]\ndistinguished_name  = req_distinguished_name\nx509_extensions     = root_ca\n\n[ req_distinguished_name ]\ncountryName             = CN\ncountryName_min         = 2\ncountryName_max         = 2\nstateOrProvinceName     = Ji Nan\nlocalityName            = Ji Nan\n0.organizationName      = TelChina\norganizationalUnitName  = GIS Engineer\ncommonName              = localhost\ncommonName_max          = 64\nemailAddress            = kongbin0325@hotmail.com\nemailAddress_max        = 64\n\n[ root_ca ]\nbasicConstraints            = critical, CA:true\n```\n\n| 配置项 | 值 | 描述 |\n| :--- | :---------- | :------------- |\n| distinguished_name | req_distinguished_name | 不用管，反正我没改 |\n| x509_extensions | root_ca | X.509证书的扩展项(我瞎说的) |\n| countryName | CN | 国家缩写，必须是两个字母 |\n| countryName_min | 2 | 就写2吧 |\n| countryName_max | 2 | 也是2。。。 |\n| stateOrProvinceName | ShanDong | 所在省 |\n| localityName | Ji Nan | 所在市 |\n| 0.organizationName | TelChina | 所在公司 |\n| organizationalUnitName | GIS Engineer | 职位 |\n| commonName | localhost | 自己的域名 |\n| commonName_max | 64 | 我抄的 |\n| emailAddress | kongbin0325@hotmail.com | 邮箱 |\n| emailAddress_max | 64 | 还是抄的 |\n| basicConstraints | critical, CA:true | 照着我的写就行！ |\n\n** 注意：countryName和 commonName要特别注意，其他的都OK ！ **\n\n第二个文件`Localhost.ext`:\n```\nsubjectAltName = @alt_names\nextendedKeyUsage = serverAuth\n\n[alt_names]\nDNS.1   = localhost\n```\n| 配置项 | 值 | 描述 |\n| :--- | :---------- | :------------- |\n| subjectAltName | @alt_names | 不用管，反正我没改 |\n| extendedKeyUsage | serverAuth | 不用管，反正我没改 |\n| DNS.1 | localhost | 设置域名 |\n| DNS.2 | 123.123.32.34 | 懂吧，可以设置多个域名（这个IP是我瞎写的） |\n\n然后，在`C:\\OpenSSL-Win64\\bin`中打开`cmd`，准备执行上面三条语句。但是第一条语句就报了错，发现无法生成*.cer和*.req文件（估计是软件版本问题导致的），又是百度，又是谷歌，还是Stack Overflow的，消耗了不少时间。最后根据以下报错信息：\n```bash\nSubject does not start with \"/\"\nProblems makeing certificate request\n```\n我尝试着将`-subj`参数删除，执行了一次，提示我输入`Localhost.cnf`文件中`req_distinguished_name`的配置项（按照提示重新输入一次就可以了）。以此执行如下：\n```\n$ openssl req -x509 -newkey rsa:2048 -out LocalhostCA.cer -outform PEM -keyout LocalhostCA.pvk -days 10000 -verbose -config LocalhostCA.cnf -nodes -sha256\n```\n同理，第二条语句也把`-subj`参数删除，执行过程中需要输入一些参数，最后执行成功。\n```\n$ openssl req -newkey rsa:2048 -keyout Localhost.pvk -out Localhost.req -sha256 -nodes\n```\n第三条语句没有`-subj`选项，直接执行即可：\n```\n$ openssl x509 -req -CA LocalhostCA.cer -CAkey LocalhostCA.pvk -in Localhost.req -out Localhost.cer -days 10000 -extfile Localhost.ext -sha256 -set_serial 0x1111\n```\n\n### 4.2 配置证书和Nginx\n将生成的Localhost.cer和Localhost.pvk文件复制到Nginx的conf目录中。\n修改nginx.conf文件，添加如下内容：\n```conf\n# HTTPS server\nserver{  \n    listen 443;  \n    server_name localhost;  \n    ssl on;\n    ssl_certificate Localhost.cer;  \n    ssl_certificate_key Localhost.pvk; \n    ssl_session_timeout 5m;  \n    ssl_protocols SSLv2 SSLv3 TLSv1;  \n    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;  \n    ssl_prefer_server_ciphers on;  \n    add_header 'Access-Control-Allow-Headers' 'Content-Type';  \n    add_header 'Access-Control-Allow-Origin' '*';  \n    add_header 'Access-Control-Allow-Methods' 'GET';  \n     \n    location / {  \n        root html; \n        index index.html 50x.html;  \n    } \n}\n\n```\n\n### 4.3 重启Nginx\n```\n$ nginx -s reload\n```\n\n### 4.4 导入证书\n在IE中打开Internet选项 -> 内容 -> 证书 -> 受信任的根证书颁发机构  -> 导入 -> LocalhostCA.cer。\n尝试访问`https://localhost/arcgis_js_api/library/4.6/init.js`，在网址的左侧显示一个小绿锁则表示HTTPS配置成功，自此所有配置过程都已经完成。\n\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<hr>\n<div style=\"text-align: center;font-weight: bold;\">\n    全文重点来了！\n</div>\n\n```C++\n// 值此3.8女神节，祝福所有的女性：\nfor (int i = 0; i < forever; i++) {\n    printf(\"Happiness Everyday!\");\n}\n```\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["GIS","Nginx","OpenSSL","代理"],"categories":["gis"]},{"title":"吾爱破解论坛2018年3月13日十周年开放注册通知","url":"/posts/224769818/","content":"**吾爱破解论坛注册喜讯：**\n说起吾爱，小白的福利，老司机的神站，每个人都想拥有一个账号。吾爱破解论坛值此十周年之际，开放了注册功能，有需要的小伙伴千万不要再错过了。\n\n<!--more-->\n\n<div style=\"text-align: center;font-weight: bold;font-size: 2rem; color: red\">\n\t喜讯、喜讯、喜讯\n</div><div style=\"text-align: center;font-weight: bold;font-size: 1.5rem\">\n\t<span>吾爱破解论坛开通开放注册</span>\n\t<span>2018年3月13日12:00-14:00和20:00-22:00</span>\n</div><div style=\"text-align: center;font-weight: bold;font-size: 1.5rem;padding-top: 0;margin-top: 0;height: 106px;line-height: 106px\"><a href=\"https://www.52pojie.cn/?fromuid=575811\" style=\"text-align: center;\">我要吾爱</a></div>\n<div></div>\n***注册注意事项：***\n\n1. 注意不要错过注册时间\n2. 认真读注册须知（需要等10分钟）\n3. 事先把注册信息写在本子或word里（独一无二的邮箱和用户名） [需要准备什么](https://www.52pojie.cn/misc.php?mod=faq&action=faq&id=15&messageid=16)\n4. 耐心检查填写内容（看是否都符合要求）\n5. 邮箱验证阶段，有的要到邮箱的垃圾箱中查看有没有验证邮件，而有的邮箱则需要设置白名单才能收到验证邮件 [帮助](https://www.52pojie.cn/thread-98585-1-1.html)\n\n<div style=\"text-align: center;font-weight: bold;font-size: 1.5rem\">\n\t祝愿小伙伴们都能获得自己的吾爱账号！\n</div><div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["活动","吾爱破解"],"categories":["tips"]},{"title":"Nginx学习入门","url":"/posts/547195145/","content":"**Nginx让系统部署花样百出：**\n在系统部署时，遇到了一个需要多方考虑的安全问题，出于架构师老大的一句话，说先用Nginx做下代理（后来讨论，此方法治标不治本，就放弃了此方法，但是Nginx还是看了那么一会儿），菜鸟如我百度谷歌一番，稍微了解了一些Nginx的最基本用法。\n\n<!--more-->\n\n## Nginx简介\n\n上面已经说了是大佬的一句话，其实在此之前我也使用过一些简单的反向代理，解决跨域问题（学的就是毛毛雨），在生产环境中还没真正使用过。那么老大说道了Nginx，那学习之前得了解Nginx是什么？能做什么，优势是什么？\n\n**是什么**\n\n是一个高性能的[HTTP](https://baike.baidu.com/item/HTTP)和[反向代理](https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86)服务器，也是一个IMAP/POP3/SMTP服务器。\n\n**能做什么？**\n\n* 反向代理\n* 正向代理\n* HTTP服务器\n* 负载均衡（什么鬼，，，）\n\n**优势有哪些？**\n\n- 轻量web服务器\n- 适合做静态请求和反向（不适合做动态请求，动态用apache）\n- 抗高并发，nginx 处理请求异步非阻塞，使用较低的资源支持更高的并发数\n- 负载均衡\n\n## location配置\n\n 以下内容只讲了自己用到的，在讲解方面可能没有那么标准，差不多都是自己理解和实践的，希望能让大家更容易理解和使用吧！\n\n基本语法：\n\n```nginx\nlocation [=|~|~*|^~] /uri/ { \n  … \n}\n```\n\n1. = 严格匹配。如果这个查询匹配，那么将停止搜索并立即处理此请求。\n2. ~ 为区分大小写匹配(可用正则表达式)\n3. !~为区分大小写不匹配\n4. ~* 为不区分大小写匹配(可用正则表达式)\n5. !~*为不区分大小写不匹配\n6. ^~ 如果把这个前缀用于一个常规字符串,那么告诉nginx 如果路径匹配那么不测试正则表达式。\n\n```nginx\nlocation / {\n  root   html;\n  index  index.html index.htm;\n}\n```\n\n## 使用root、alias和proxy_pass\n\n由于最近在看[layui](http://www.layui.com)的一些东西（不是广告），就顺手拿来做个演示！（以下提到的layui，指的是layui官方提供[社区模板](http://www.layui.com/template/fly/)的html目录。\n\n阅读到这时，如果你还没有nginx环境，请点击[下载]()搭建你的环境，\n\n* 点击[Nginx官网](http://nginx.org)，点击最新带有`mainline version`字样的链接，建议下载`Stable version`版本；\n* 下载得到一个zip包，解压到你想放置的目录，双击启动`nginx.exe`\n\n\n\n>  *另外再说明一下实践的环境，本地解析使用的80端口，反向代理转发的url不带端口*\n>\n>  *以下代码均在`nginx/conf/`文件夹下的`nginx.conf`文件中修改*\n>\n>  *在修改保存`nginx.conf`后，记得使用`nginx -s reload`重载配置文件，使其生效*\n\n使用alias 设置本地虚拟目录，后面必须加上 / ，alias 指定本地目录，例如Windows系统上设置为 `D:/html/app/`，若是使用mac或linux，路径最后也要加上 / ，例如 `~/html/app/` or `/home/bruce/html/app/`。\n\n以下两个方法都能跳转到layui中，这个相当于直接访问 `D:/ComSoftwares/nginx-1.13.7/html/layui`目录，可以理解为在root目录下，访问layui目录：\n\n```nginx\nlocation ^~ /layui {\n\troot D:/ComSoftwares/nginx-1.13.7/html/;\n}\n```\n\n访问`localhost/alayui`或`localhost/alayui/`自动代理到`D:/ComSoftwares/nginx-1.13.7/html/layui/`目录下\n\n```nginx\nlocation /alayui {\n\talias D:/ComSoftwares/nginx-1.13.7/html/layui/;\n}\n```\n\n使用 `=` 匹配访问链接 只能匹配`localhost/blayui`或者`localhost/blayui/`，对于子目录无法进行访问\n即对`localhost/blayui/jie/add.html` 无法进行访问\n可以看出 = 是严格匹配\n\n```nginx\nlocation = /blayui/ {\n\tproxy_pass http://localhost/layui/;\n}\n```\n\n三种方法的利弊：\n\n* 第一种和没设置一样（ 为了学习root）\n* 第二种根据访问的链接，去代理到一定的目录下，即代理了当前链接，又代理了子目录\n* 第三种只严格匹配了当前链接，对于子目录无法进行访问\n\n>  *推荐使用第二种：alias方法*\n\n## 使用rewrite、proxy_pass和正则表达式\n\n下面的方法统一使用了正则表达式来解决访问链接\n添加访问目录为`/apis`的代理配置，用`127.0.0.1:80/apis`重定向http://www.layui.com，\n在ajax中访问`/apis/demo/table/user`,相当于访问http://www.layui.com/demo/table/user\n\n```nginx\nlocation /apis {\n  rewrite  ^/apis/(.*)$ /$1 break;\n  proxy_pass   http://www.layui.com;\n}\n```\n\n>  参考学习 http://blog.csdn.net/tjcyjd/article/details/50897959\n\n总的来说，alias使用简单粗暴，转发本地目录；而正则表达式使用起来更爽，处理的情况更多，让更多事情变得简单，运行高效，低资源占用，代理强大的处理方法。\n\n由于学习Nginx的时间有限，只针对自己遇到的问题进行了研究，如若有不对或不合适的地方，请批评指正，谢谢！\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Nginx","代理"],"categories":["languages"]},{"title":"Cesium简介与环境搭建","url":"/posts/3718307484/","content":"\n**Cesium的Web 3DGIS应用：**\nCesium是WebGIS领域的一个很重要的方向，它具有开源，更新快、、跨平台、跨浏览器和无需插件支持的Web 3DGIS引擎，在地里信息行业有着很好的应用前景。\n\n<!--more-->\n\n## Cesium简介\n\n<div style=\"text-align: center;\">![Cesium](https://coding.net/u/ibrucekong/p/images/git/raw/master/cesium-office-site.png)</div>\n\n> 官网介绍\n>\n> Cesium is a JavaScript library for creating 3D globes and 2D maps in a web browser without a plugin. It uses WebGL for hardware-accelerated graphics, and is cross-platform, cross-browser, and tuned for dynamic-data visualization.\n\n简单来讲就是说，Cesium是一个可以同时支持2D和 3D地图的引擎，无需浏览器插件支持的JavaScript开发库。但是浏览器必须支持WebGL，不然就是扯淡、免谈，而且Cesium能使用本地硬件加速图形渲染，具有跨平台、跨浏览器的特性，另外还可以优化动态数据的可视化。（对于英语没过六级的人，表示翻译压力有点大，看不懂的请移步）\n\nCesium支持三维地球（3D），二维地图（2D）以及2.5D哥伦布视图（2.5D），还可以实现基于时间轴的动态数据展示\n\n## Cesium优缺点\n\n**优点：**\n\n* 开源\n* 框架更新迭代周期短\n* 无需插件支持\n* 跨平台、跨浏览器\n* 地图数据展示效果比较好\n\n**缺点**\n\n* 和商业软件相比，三维分析处理相对较弱\n* 地图组件不够全面\n\n## 搭建Cesium开发环境\n\n搭建环境向来不止一种方式，这里提供三种方式：一、npm安装；二、Github下载；三、依赖第三方发布组件\n\n### 下载Cesium组件\n\n#### npm下载\n\n这是一种官网推荐的方式，在当前前端React、Angular、Vue三足鼎立的时期，基于npm安装组件的项目越来越多，Cesium官方也推送了npm下载方式：`npm install cesium`(默认你已经配置了node.js和npm环境)，执行后，会在当前目录下看到一个`node_moudles`文件夹，里面有下载下来的cesium依赖包，具体目录在`node_modules\\cesium\\Build\\Cesium`中，也可以将Cesium文件夹拷贝出来，放到工程中使用。\n\n#### Github下载\n\n在Github中找组件，一般方式为：\n\n* 打开Cesium在Github上的[链接](https://github.com/AnalyticalGraphicsInc/cesium)，直接点击`clone or download`选择`download zip`即可下载Cesium工程文件；\n* 如果系统中安装了Git环境，可以使用以下方法获取：\n\n```bash\ngit clone https://github.com/AnalyticalGraphicsInc/cesium.git\n```\n\n\n\n> 但是本文建议大家，在找到自己想要使用的组件时，尽量去`releases`下面去下载发布版本，这样的版本更加稳定。\n\n本文以下载`releases`中的zip包为例，\n\n* 打开`releases`的[链接](https://github.com/AnalyticalGraphicsInc/cesium/releases)，下载最新版本的zip包，解压到想要放置的文件夹下面\n* 打开cmd命令终端，`cd`进入到Cesium文件夹下\n* 使用`npm install`安装组件依赖\n* `npm start`启动服务，打开浏览器访问`http://localhost:8080/`，可以看到一些入门链接和示例。\n\n<div style=\"text-align: center;\">![Cesium](https://coding.net/u/ibrucekong/p/images/git/raw/master/cesium-office-demo.png)</div>\n\n以上是官方提供的学习链接，但是我要引用的组件呢？\n\n细心的童鞋可能看到了根目录下有一个build目录，和`npm install cesium`下载下来的Cesium文件夹很相似，没错就是它，打开build会看到有三个目录`Cesium, CesiumUnminified, Documentation`，第一个文件夹是Cesium的未压缩版本的组件，第二个文件夹是经过压缩的组件，第三个文件夹是一些接口文档。\n\n> 一般开发期间引用未压缩版本，便于调试\n>\n> 部署发布期间使用压缩版本，结余流量，提高访问速度\n\n#### 第三方组件依赖\n\n博主也提供了第三方组件的依赖，虽规模不大，都是一些自己或者常用的一些组件。由于是刚建立，不管是功能还是组件库都比较少，后续会慢慢增加的，不仅加入自己上传的库，还会增加一些第三方的、使用CDN加速的库链接。\n\n打开[https://library.brucekong.com](https://library.brucekong.com)，会看到当前库里面都有哪些组件，把鼠标移动到链接上，会自动选中该链接，直接按`Ctrl + C`就可以将链接复制，放到你需要引用的位置。\n\n### 引用库文件\n\n前两种方法中，将Cesium文件夹放入到工程中，引用`Cesium/Cesium.js和Cesium/Widgets/Widgets.css`即可，第三种方法，直接将链接放入到`src`中即可。\n\n### 完成Hello World\n\n前两种都是使用本地文件引用形式，不在演示，只演示第三种，废话少说，直接上代码：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <!-- Use correct character set. -->\n  <meta charset=\"utf-8\">\n  <!-- Tell IE to use the latest, best version. -->\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\">\n  <title>Hello World!</title>\n  <script src=\"https://library.brucekong.com/cesium/1.41/Cesium.js\"></script>\n  <style>\n      @import url(https://library.brucekong.com/cesium/1.41/Widgets/widgets.css);\n      html, body, #cesiumContainer {\n          width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;\n      }\n  </style>\n</head>\n<body>\n  <div id=\"cesiumContainer\"></div>\n  <script>\n    var viewer = new Cesium.Viewer('cesiumContainer');\n  </script>\n</body>\n</html>\n```\n\n<div style=\"text-align: center;\">![Cesium](https://coding.net/u/ibrucekong/p/images/git/raw/master/cesium-hello-world.png)</div>\n\n> 注意，引用本地文件时，需要将工程放入到Tomcat、Nginx或Apache等web服务器中运行；如果不放进服务器中，直接运行将会报错，而引用第三方发布的组件不会出现这种情况。\n\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Cesium","3D Map"],"categories":["languages"]},{"title":"从零开始搭建自己的博客天地(上)","url":"/posts/3667539278/","content":"**建站，重在折腾：**\n\n之前提及过公网建站的文章（站内搜索[Ctrl+F]：Say you again），但是没有讲具体的流程，在踩过N个坑之后，在这里讲一下自己建站的经验，让更多的爱好者轻松完成建（折）站（腾）工作。下面开始唐僧念经时间~\n\n<!--more-->\n\n## 站点准备\n要搭建个人博客，需要一些条件的支持，一般包括如下内容：\n\n-   [GitHub](https://github.com)、[Coding](https://coding.net)、[Gitlab](https://gitlab.com)、[Gitee](https://gitee.com)等支持Pages服务的代码托管平台\n-   [Themes of Hexo](https://hexo.io/themes/)\n\n<div style=\"text-align: center\">![hexo-theme](https://coding.net/u/ibrucekong/p/images/git/raw/master/gits.png)</div>\n\n\n首先在第一个选项中选择一个适合自己的托管平台，我是从GitHub到Gitee，再到Coding。当时刚接触Hexo时，只想着能在公网访问自己的博客就算成功了，然后就在GitHub上部署了自己的第一个站点（无奈太烂，只好解散）；后来，想着博客搞那么烂，有的还是搬砖搬过来的，还是体力活，站点源码就不开源了，中间用了一段时间Gitee；再后来，全世界都在HTTPS，都在使用自己的域名，那我也得跟得上潮流不是，所以综合考虑后就选择了Coding。为了少踩坑，本文就直接使用Coding作为平台进行说明。\n\n*托管平台大家可以自行选择，根据自己的需求，选择适合自己的就是最好的*\n\n然后去[主题网站](https://hexo.io/themes/)，下载自己喜欢的主题样式，天生审美残缺，这里就不给推荐了，大家自行选择。\n<div style=\"text-align: center\">![hexo-theme](https://coding.net/u/ibrucekong/p/images/git/raw/master/hexo-theme.png)</div>\n\n如果不是Git、Node.js小白，请跳过**必备技能**，直接进入**站点配置**\n## 必备技能\n\n### Git安装与配置\n\n参见[Git安装与配置](https://blog.brucekong.com/posts/3219987363/)\n\n### Node安装\n\n参见[Node安装与配置](https://blog.brucekong.com/posts/3412983070/)\n\n### Hexo安装\n\n当Git和Node.js安装配置好后，还要安装hexo组件，用来创建博客项目。\n* 使用cnpm安装Hexo\n```\ncnpm i hexo-cli -g\n```\n* 使用hexo创建第一个博客：\n```\nhexo init blog\n```\n* 进入blog，安装模块\n```\ncd blog\ncnpm i\n```\n* 生成静态网页，启动服务\n```\nhexo g\nhexo s\n```\n打开服务连接[http://localhost:4000/](http://localhost:4000/)，最基本的博客项目就运行起来了，下一步就要对博客进行美化加工。\n\n### Markdown\n\n参见[Markdown学习入门](https://blog.brucekong.com/posts/417703024/)\n\n## 站点配置\n\n找到好Hexo主题后，找到主题托管的工程，一般都会有一定的说明，以next主题为例：\n* 首先`cd`进入到`blog`根目录；\n`git clone https://github.com/hexojs/hexo-theme-next themes/next`\n`next`主题就已经放入到`blog/themes`文件夹下了，如果不对`next`工程进行PR操作，或者为了减小`blog`的体积，可以把`next`文件夹下的.git文件夹删除。\n* 打开`blog/_config.yml`文件\n修改theme\n```\ntheme: next\n```\n* 先清理已有的工程，重新生成静态网页，并启动服务\n```\nhexo clean\nhexo g\nhexo s\n或者\nhexo clean & hexo g & hexo s\n```\n为确保没有浏览器缓存，我一般会加上`hexo clean`，其实只要页面不报错一般也是不需要的，打开服务连接[http://localhost:4000/](http://localhost:4000/)，是不是发现博客主题已经改变了~~~\n\n## 发布站点\n\n到这个时候，肯定有人说：“你讲了这么多，博客不还只是在本地用，哪里到公网访问了，哪里用到Coding了...”\n<div style=\"text-align: center;font-size: 2.5rem;padding: 20px;box-shadow: inset 0px 0px 30px red;display: none\">客官，别急，这就来!</div>\n* （假设你的用户名是demo）先到coding上新建一个`demo.coding.me`的项目，打开`https://coding.net/u/demo/p/demo.coding.me/git/pages/static`，开启`Pages服务`，Coding会自动帮你申请`HTTPS`，自此留着待用...\n* 打开`blog/_config.yml`文件\n* 修改deploy参数，格式要严格遵守deploy参数（不知道的，可以[Hexo部署](https://hexo.io/zh-cn/docs/deployment.html)获取帮助）\n```\ndeploy: \n  type: git\n  repo: git@git.coding.net:demo/demo.coding.me.git\n  branch: master\n  message: commit message\n```\n* 然后，打开Git Bash，cd到blog目录，执行：\n`hexo clean & hexo g & hexo d`\n注意：这个过程可能需要你输入账号密码，也可能没有-.-\n* 打开网页中的`demo.coding.me`仓库工程，刷新网页检查代码是否已经部署了；\n* 成功后，打开`https://demo.coding.me`，如果未能打开，需等待几分钟等待Coding解析刚部署的网页。\n\n## 新增博文\n\n站点部署好后，要做到博客由访问量和活跃度需要及时更新博文，下面演示一下怎么新增一篇博文：\n\n* 首先cd到blog根目录\n* 新增博文\n```\nhexo n \"newpage\"     这是简写\nhexo new \"newpage\"   这是全拼\n```\n* 然后在blog/source/_posts文件夹中，出现一个`newpage.md`文档，并附带默认文章头\n```\n---\ntitle: newpage\ndate: 2017-12-06 12:06:22\ntags:\n---\n```\n* 尝试修改博文内容\n```\n---\ntitle: newpage\ndate: 2017-12-06 12:06:22\ntags: tips\n---\n# 我是一级标题\n## 我是二级标题\n\n* 我是列表1\n* 我是列表2\n\n！[我是图片](https://blog.brucekong.com/favicon.png)\n\n[我是链接](https://blog.brucekong.com)\n\n<div style=\"text-align: center;\">我是居中内容</div>\n```\n* 保存文档，本地查看博文\n```\nhexo clean & hexo g & hexo s\n```\n打开服务连接[http://localhost:4000/](http://localhost:4000/)，检查博文板式是否符合你的预期效果\n* 部署本篇博客到Coding服务器\n在`blog/_config.yml`的deploy选项的message中填入本次提交的log文，一遍以后查找\n```\ndeploy: \n  type: git\n  repo: git@git.coding.net:demo/demo.coding.me.git\n  branch: master\n  message: add a new article\n```\n执行部署命令：\n```\nhexo d\n```\n* 打开网页中的`demo.coding.me`工程，刷新网页检查代码是否已经部署了；\n* 成功后，打开`https://demo.coding.me`，已经可以看到新增的博文了。\n\n通过以上唠唠叨叨后，能实现最基本的Coding建站，新增博文，希望能对大家有所帮助！\n\n本次主要完成了基于Hexo技术搭建的Coding Pages个人博客，实现了环境搭建、初始化博客项目、新增博文、部署博文，并是使用HTTPS进行访问。\n\n**TODO：有待增加的包括（1）解析_config.yml参数，（2）使用图床管理博文图片，（3）绑定域名**\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Hexo","Blog"],"categories":["tips"]},{"title":"使用BeautifulSoup和pdfkit爬取菜鸟教程到pdf文件!","url":"/posts/1297890910/","content":"**锋利的BeautifulSoup：**\n\nBeautifulSoup是Python爬虫里面使用较为广泛的库，其主要功能是从网页中抓取数据，可以使用较少的代码实现完整的数据爬取工作。\n\n<!--more-->\n\n## BeautifulSoup简介\n&emsp;&emsp;BeautifulSoup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。\n\n## pdfkit简介\n&emsp;&emsp;pdfkit是一个把HTML+CSS格式的文件转换成PDF格式文档的一种工具。它是对html转pdf工具包wkhtmltopdf的封装，所以必须要安装wkhtmltopdf，并将wkhtmltopdf的安装路径配置到系统环境PATH中。\n> 可以参考：[pdfkit与wkhtmltopdf的安装与使用](http://blog.csdn.net/appleyuchi/article/details/70947138)\n\n## 爬取的关键代码\n\n&emsp;&emsp;列举了一些共有变量和设置的变量\n```python3\n# 比如爬取python3，网址：http://www.runoob.com/python3/python3-tutorial.html\n# 对该url进行拆分，对以下四个参数进行配置，一般只修改language\nlanguage = 'python3'\nlist_tag = '_top'\ncontent_tag = 'content'\npath_wkthmltopdf = r'C:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltopdf.exe'\n# 以下参数不用配置\nchild_url = '/' + language\nurl_tag = child_url + '/'\noutput_name = u\"runoob_\" + language + r\"教程.pdf\"\n```\n\n&emsp;&emsp;get_url_title_list方法：获取python的章节url\n```python3\ndef get_url_title_list():\n    \"\"\"\n    获取所有URL和Title目录列表\n    :return:\n    \"\"\"\n    root = root_url\n    temp_child_url = child_url\n    resp = requests.get(root + temp_child_url)\n    resp.encoding = 'utf-8'\n    soup = BeautifulSoup(resp.text, \"html.parser\")\n    x = soup.find(\"div\", class_=\"design\")\n    x = x.find_all(\"a\", target=list_tag)\n    title = []\n    url_path = []\n    for i in x:\n        value = i.string.strip()\n        title.append(value)\n        temp_href = i.get('href').strip()\n        if temp_href.find(url_tag) >= 0:\n            href = root + temp_href\n        else:\n            href = root + temp_child_url + '/' + temp_href\n        url_path.append(href)\n    return title, url_path\n```\n&emsp;&emsp;parse_url_to_html方法：将爬取的目标网页存储为html文件\n\n```python3\ndef parse_url_to_html(url, name):\n    \"\"\"\n    解析URL，返回HTML内容\n    :param url:解析的url\n    :param name: 保存的html文件名\n    :return: html\n    \"\"\"\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.content, 'html.parser')\n        # 正文\n        body = soup.find(id=content_tag)\n        # 标题\n        title = body.find('h1')\n        if title is None:\n            title = body.find_all('h2')[0]\n            title_tag = soup.new_tag('h1')\n            title_tag.string = title.string\n            title = title_tag\n        # 标题加入到正文的最前面，居中显示\n        center_tag = soup.new_tag(\"center\")\n        center_tag.insert(1, title)\n        body.insert(1, center_tag)\n        html = str(body)\n        # body中的img标签的src相对路径的改成绝对路径\n        pattern = \"(<img .*?src=\\\")(.*?)(\\\")\"\n        def func(m):\n            if not m.group(3).startswith(\"http\"):\n                if m.group(2).find('https') >= 0:\n                    return m.group(1) + m.group(2) + m.group(3)\n                if m.group(2).find('runoob.com') >= 0:\n                    rtn = m.group(1) + \"http:\" + m.group(2) + m.group(3)\n                    print(rtn)\n                else:\n                    rtn = m.group(1) + root_url + m.group(2) + m.group(3)\n                    print(rtn)\n                return rtn\n            else:\n                return m.group(1) + m.group(2) + m.group(3)\n        html = re.compile(pattern).sub(func, html)\n        html = html_template.format(content=html)\n        html = html.encode(\"utf-8\")\n        with open(name, 'wb') as f:\n            f.write(html)\n        return name\n    except Exception as e:\n        logging.error(\"解析错误\", exc_info=True)\n```\n\n<div align=center> ![parse_url_to_html](https://coding.net/u/ibrucekong/p/images/git/raw/master/gen-html.png) </div>\n\n&emsp;&emsp;save_pdf方法：将html文件转为pdf文件\n```python3\ndef save_pdf(htmls, file_name):\n    \"\"\"\n    把所有html文件保存到pdf文件\n    :param htmls:  html文件列表\n    :param file_name: pdf文件名\n    :return:\n    \"\"\"\n    config = pdfkit.configuration(wkhtmltopdf=path_wkthmltopdf)\n    options = {\n        'page-size': 'Letter',\n        'margin-top': '0.75in',\n        'margin-right': '0.75in',\n        'margin-bottom': '0.75in',\n        'margin-left': '0.75in',\n        'encoding': \"UTF-8\",\n        'custom-header': [\n            ('Accept-Encoding', 'gzip')\n        ],\n        'cookie': [\n            ('cookie-name1', 'cookie-value1'),\n            ('cookie-name2', 'cookie-value2'),\n        ],\n        'outline-depth': 10,\n    }\n    pdfkit.from_file(htmls, file_name, options=options, configuration=config)\n```\n<div align=center>![save_pdf](https://coding.net/u/ibrucekong/p/images/git/raw/master/gen-pdf.png)</div>\n\n&emsp;&emsp;append_pdf方法：拼接pdf\n```python3\ndef append_pdf(input1, output1, bookmark):\n    bookmark_num = output1.getNumPages()\n    print(bookmark_num)\n    for page_num in range(input1.numPages):\n        output1.addPage(input1.getPage(page_num))\n\n    output1.addBookmark(bookmark, bookmark_num)\n```\n&emsp;&emsp;在上述方法执行完成后，执行以下代码，将拼接的pdf输出到本地\n```python3\noutput.write(open(output_name, \"wb\"))\n```\n<div align=center>![append_pdf](https://coding.net/u/ibrucekong/p/images/git/raw/master/gen-total-pdf.png)</div>\n\n## 完整代码\n\n\n```python3\n# -*-coding:utf-8-*-\nimport os\nimport re\nimport time\nimport sys\nimport logging\nimport pdfkit\nimport requests\nfrom bs4 import BeautifulSoup\nfrom PyPDF2 import PdfFileWriter, PdfFileReader\nhtml_template = \"\"\" \n<!DOCTYPE html> \n<html lang=\"en\"> \n<head> \n    <meta charset=\"UTF-8\"> \n</head> \n<body> \n{content} \n</body> \n</html> \n\"\"\"\nroot_url = \"http://www.runoob.com\"\n# 针对Runoob.com的爬虫示例\n# 列入要对该网站的python3进行爬虫,点开 python3，网址默认为：http://www.runoob.com/python3/python3-tutorial.html\n# 对该url进行拆分，对以下四个参数进行配置，一般只修改language\nlanguage = 'python3'                                                      # 要爬虫的分类------针对不同的内容进行修改\nlist_tag = '_top'                                                         # 对左侧列表的class检索------一般不需要修改\ncontent_tag = 'content'                                                   # 对正文的id检索------一般不需要修改\npath_wkthmltopdf = r'C:\\\\Program Files\\\\wkhtmltopdf\\\\bin\\\\wkhtmltopdf.exe'    # 本地 wkhtmltopdf 的配置------根据自己电脑情况配置\n# 以下参数不用配置\nchild_url = '/' + language                                                # 定义子url\nurl_tag = child_url + '/'                                                 # url_tag是对左侧列表中的url出现特殊情况下的判断\noutput_name = u\"runoob_\" + language + r\"教程.pdf\"                          # 爬虫的文件名\ndef parse_url_to_html(url, name):\n    \"\"\"\n    解析URL，返回HTML内容\n    :param url:解析的url\n    :param name: 保存的html文件名\n    :return: html\n    \"\"\"\n    try:\n        response = requests.get(url)\n        soup = BeautifulSoup(response.content, 'html.parser')\n        # 正文\n        body = soup.find(id=content_tag)\n        # 标题\n        title = body.find('h1')\n        if title is None:\n            title = body.find_all('h2')[0]\n            title_tag = soup.new_tag('h1')\n            title_tag.string = title.string\n            title = title_tag\n        # 标题加入到正文的最前面，居中显示\n        center_tag = soup.new_tag(\"center\")\n        center_tag.insert(1, title)\n        body.insert(1, center_tag)\n        html = str(body)\n        # body中的img标签的src相对路径的改成绝对路径\n        pattern = \"(<img .*?src=\\\")(.*?)(\\\")\"\n        def func(m):\n            if not m.group(3).startswith(\"http\"):\n                if m.group(2).find('https') >= 0:\n                    return m.group(1) + m.group(2) + m.group(3)\n                if m.group(2).find('runoob.com') >= 0:\n                    rtn = m.group(1) + \"http:\" + m.group(2) + m.group(3)\n                    print(rtn)\n                else:\n                    rtn = m.group(1) + root_url + m.group(2) + m.group(3)\n                    print(rtn)\n                return rtn\n            else:\n                return m.group(1) + m.group(2) + m.group(3)\n        html = re.compile(pattern).sub(func, html)\n        html = html_template.format(content=html)\n        html = html.encode(\"utf-8\")\n        with open(name, 'wb') as f:\n            f.write(html)\n        return name\n    except Exception as e:\n        logging.error(\"解析错误\", exc_info=True)\n# 要去除所有的div标签\n# 移除div（如果要移除a标签，把div换成a即可）\n# remove_tag(html, \"div\")\ndef remove_tag(text, tag):\n    return text[:text.find(\"<\" + tag + \">\")] + text[text.find(\"</\" + tag + \">\") + len(tag) + 3:]\ndef get_url_title_list():\n    \"\"\"\n    获取所有URL和Title目录列表\n    :return:\n    \"\"\"\n    root = root_url\n    temp_child_url = child_url\n    resp = requests.get(root + temp_child_url)\n    resp.encoding = 'utf-8'\n    soup = BeautifulSoup(resp.text, \"html.parser\")\n    x = soup.find(\"div\", class_=\"design\")\n    x = x.find_all(\"a\", target=list_tag)\n    title = []\n    url_path = []\n    for i in x:\n        value = i.string.strip()\n        title.append(value)\n        temp_href = i.get('href').strip()\n        if temp_href.find(url_tag) >= 0:\n            href = root + temp_href\n        else:\n            href = root + temp_child_url + '/' + temp_href\n        url_path.append(href)\n    return title, url_path\ndef save_pdf(htmls, file_name):\n    \"\"\"\n    把所有html文件保存到pdf文件\n    :param htmls:  html文件列表\n    :param file_name: pdf文件名\n    :return:\n    \"\"\"\n    config = pdfkit.configuration(wkhtmltopdf=path_wkthmltopdf)\n    options = {\n        'page-size': 'Letter',\n        'margin-top': '0.75in',\n        'margin-right': '0.75in',\n        'margin-bottom': '0.75in',\n        'margin-left': '0.75in',\n        'encoding': \"UTF-8\",\n        'custom-header': [\n            ('Accept-Encoding', 'gzip')\n        ],\n        'cookie': [\n            ('cookie-name1', 'cookie-value1'),\n            ('cookie-name2', 'cookie-value2'),\n        ],\n        'outline-depth': 10,\n    }\n    pdfkit.from_file(htmls, file_name, options=options, configuration=config)\ndef append_pdf(input1, output1, bookmark):\n    bookmark_num = output1.getNumPages()\n    print(bookmark_num)\n    for page_num in range(input1.numPages):\n        output1.addPage(input1.getPage(page_num))\n    output1.addBookmark(bookmark, bookmark_num)\ndef main():\n    output = PdfFileWriter()\n    start = time.time()\n    file_name = u\"temp_\"\n    result = get_url_title_list()\n    titles = result[0]\n    urls = result[1]\n    print(titles)\n    print(urls)\n    for index, url in enumerate(urls):\n        parse_url_to_html(url, str(index) + \".html\")\n    htmls = []\n    pdfs = []\n    for i in range(0, len(urls)):\n        htmls.append(str(i) + '.html')\n        pdfs.append(file_name + str(i) + '.pdf')\n        save_pdf(str(i) + '.html', file_name + str(i) + '.pdf')\n        print(u\"转换完成第\" + str(i) + '个html')\n    i = 0\n    for pdf in pdfs:\n        fd = open(pdf, 'rb')\n        append_pdf(PdfFileReader(fd), output, titles[i])\n        i = i + 1\n        print(u\"合并完成第\" + str(i) + '个pdf' + pdf)\n    output.write(open(output_name, \"wb\"))\n    print(u\"输出PDF成功！\")\n    for html in htmls:\n        os.remove(html)\n        print(u\"删除临时文件\" + html)\n    for pdf in pdfs:\n        os.remove(pdf)\n        print(u\"删除临时文件\" + pdf)\n    total_time = time.time() - start\n    print(u\"总共耗时：%f 秒\" % total_time)\nif __name__ == '__main__':\n    try:\n        main()\n    except OSError as err:\n        print(\"OS error: {0}\".format(err))\n    except ValueError:\n        print(\"Could not convert data to an integer.\")\n    finally:\n        print(\"Unexpected error:\", sys.exc_info()[0])\n```\n\n## 存在的问题\n\n&emsp;&emsp;在删除中间生成的pdf时，报了一个错误(`OS error: [WinError 32]另一个程序正在使用此文件，进程无法访问。:'temp_0.pdf'`)，提示文件正在使用中，删除pdf文件失败。由于正在学习python，在多次尝试解决该问题，都以失败告终，等技能提升之后再进行修复~\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Python3","BeautifulSoup","Pdfkit","爬虫"],"categories":["languages"]},{"title":"Python3入门学习—02条件循环语句","url":"/posts/1533523788/","content":"**人生苦短，我用Python：**\n\n写程序少不了的就是条件、循环语句，在程序运行中担任了重要作用。这些语句在Python中去除了大括号的包裹，完全按照缩进来控制语句的逻辑运行，如果从侧面来看，这样的代码看着清爽不少~\n\n<!--more-->\n\n## If条件语句\n[Python](https://www.python.org/)程序语言指定任何非0和非空（null）值为true，0 或者 null为false。如果接口定义好返回值后，在判断时可以直接使用如下形式（用flag作为判断条件）：\n```python3\nif flag:\n    execute statement\n```\n同样的，python的基本条件语句为：\n```python3\nif flag:\n    execute statement\nelse:\n    execute statement\n```\n多重判断情况下：\n```python3\nif flag0:\n    execute statement0\nelse if flag1:\n    execute statement1\nelse if flag2:\n    execute statement2\nelse:\n    execute statement3\n```\n多重判断的代码看着是不是也很清爽，还有更清爽的\n在同一行写if语句：`if ( flag ) : print \"Holle World\" `\n\n## While循环语句\n对于while循环语句我们之前学的是，该语句体可能一次都不进入；然后这个循环主要重复做一些相同工作的任务。其基本形式为：\n```python3\nwhile flag:\n    execute statement\n```\n> 引用[菜鸟教程](http://www.runoob.com)上的例子\n<div style=\"text-align: center\">\n![while 动画](https://coding.net/u/ibrucekong/p/images/git/raw/master/loop-over-python-list-animation.gif)\n</div>\n\n**再次强调，在python中去除了大括号的包裹，`:`变得很重要，千万不要遗漏**\n\n> while 语句时还有另外两个重要的命令 continue，break 来跳过循环。其中continue 用于跳过该次循环，break 则是用于退出循环，此外\"判断条件\"还可以是个常值，表示循环必定成立。下面来看几个例子：\n\n打印出10及以内的所有偶数\ncontinue和break示例\n```python3\ni = 1\nwhile i<10:\n    i+=1\n    if i%2>0:\n        continue\n    print(i)\n    \n# 控制台中则打出：2 4 6 8 10\n```\n常值作为判断条件，语句必定执行，至于语句是否能退出，取决于execute statement是否会跳出循环\n如果一直循环下去，那么该语句就会成为“无限循环体”\n```python3\nwhile 1:\n    execute statement\n```\n该条件永远为true，循环将无限执行下去；\n对于控制台程序，若想要退出该程序可以按Ctrl+C\n```python3\nvar = 1\nwhile var == 1 :  \n   name = input(\"请输入你的名字 :\")\n   print(\"你的名字是: \", name)\n \nprint \"再见!\"\n```\nPython使用`while ...else`语句，需要注意的是else 中的语句会在循环正常执行完（即 while 不是通过 break 跳出而中断的）的情况下执行：\n```python3\ncount = 1\nwhile count < 6:\n   print(count, \"小于6\")\n   count = count + 1\nelse:\n   print(count, \"大于6\")\n   \n控制台中会输出（6之后不再循环了）：\n1小于6\n2小于6\n3小于6\n4小于6\n5小于6\n6大于6\n```\n最后就是简单while语句：\n```python3\nwhile flag: execute statement\n```\n\n## For循环语句\n从上面的while语句就可以看出，一般循环体内部都会有一个if判断语句，用来控制更加具体的逻辑操作。同样的，for循环语句内部一般也会嵌套if语句，用来控制更加复杂的流程。\nPython中用的最多的就是`for in`，可以表示为：\n```python3\ngroup = ['P', 'y', 't', 'h', 'o', 'n']\nfor sub in group:\n    print(sub)\n\n控制台中会输出:\nP\ny\nt\nh\no\nn\n```\n其实在Python的for循环中，字符串可以当做数组进行循环，例如：\n```python3\nfor sub in \"Python\":\n    print(sub)\n\n控制台中会输出:\nP\ny\nt\nh\no\nn\n```\n另外for循环还可以通过索引值进行遍历数组：\n```python3\ngroup = ['P', 'y', 't', 'h', 'o', 'n']\nfor index in range(len(group)):\n    print(group[index])\n\n控制台中同样会输出:\nP\ny\nt\nh\no\nn\n```\n和`while … else`一样，`for … else` 语句中的else 语句也是在循环正常执行完的情况下执行，这里不再赘述。\n\n同样的，Python中也存在着嵌套循环的情况，即一个循环体中嵌套另一个循环。for、while、if可以互相嵌套，用来完成相关逻辑操作。\n\n这里再强调几个用的比较多的关键词：`break、continue、pass`\nbreak和continue在前面已经提到过，这里再多说一句，break、continue语句用在while和for循环中，其中break语句将停止执行最深层的循环，并开始执行下一行代码；continue语句是跳过当前循环的剩余语句，然后继续进行下一轮循环。\npass语句是一个空语句，是为了保持程序结构的完整性，一般是做占位语句，引用菜鸟教程的示例：\n```python3\nfor sub in \"Python\":\n   if sub == \"y\":\n      pass\n      print(\"占位符\")\n   print(letter)\n\n控制台中会输出:\nP\n占位符\nt\nh\no\nn\n```\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Python3"],"categories":["languages"]},{"title":"Python3入门学习—01环境搭建","url":"/posts/58933767/","content":"**人生苦短，我用Python：**\n\nPython3作为一个比较容易入门的语言，实现相同的功能，Python可以使用较少的代码来实现，正所谓人生苦短，我用Python。\n\n<!--more-->\n\n## Python简介？\n&emsp;&emsp;[Python](https://www.python.org/)是一种解释型、面向对象、动态数据类型的高级程序设计语言。Python由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。像Perl语言一样, Python 源代码同样遵循 GPL(GNU General Public License)协议。\n&emsp;&emsp;现在python存在的版本包括：`Python2.*`、`Python3.*`。本系列主要讨论Python3版本的学习历程。\n\n## 为什么要学习Python？\n&emsp;&emsp;之前学习了一点Java，但是好奇心比较重，就学习了一下Python，改善一下自己的思维习惯，锻炼自己学习新语言的能力，而且如果只会Java的话，在一些方面还是有些不方便的地方：\n>* 系统部署\n* 网页开发\n* 发布简单\n\n&emsp;\n>另外引用知乎上一句话：写起来简单，看起来明白！\n应用领域比较广泛:Web服务器、运维测试、科学计算、组件编程、数据库编程、游戏、图像、**人工智能**、**机器人**等等。\n\n&emsp;&emsp;Python既然这么优秀为啥不去学习呢，是吧？\n\n## Python3环境搭建？\n&emsp;&emsp;Python兼容Mac、Linux、Windows系统，现以Windows系统（穷）搭（逼）建为例：\n\n* 首先去Python官网[下载](https://www.python.org/downloads/windows/)与Windows系统版本相匹配的Python3安装包(比如：64位的系统下载`Windows x86-64 executable installer`)。\n* 双击下载的exe文件，在弹出的安装界面中（记下安装路径，后面可能要用到），注意勾选`Add Python 3.* to PATH`，选择Customize installation，在弹出的安装组件列表中着重观察是否选中了`pip`，如果没有，请勾选。一路Next，直到Finish。\n* 打开cmd，输入python，验证Python是否安装配置成功。\n\n<div style=\"text-align: center;\">![valid python](https://coding.net/u/ibrucekong/p/images/git/raw/master/valid-python.png)</div>\n\n**注意:如果验证不成功，可将前面记录的安装路径和Scripts目录一同放入系统的环境变量中。**\n\n## Python3的Hello World怎么写？\nLet's do it...\n\n```print('Hello', 'World!')```\n\nDone...\n\n<div style=\"text-align: center;\">![Hello World](https://coding.net/u/ibrucekong/p/images/git/raw/master/python-hello-world.png)</div>\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Python3"],"categories":["languages"]},{"title":"Node安装与配置","url":"/posts/3412983070/","content":"**很火的一种技术：**\n\nNode.js是之前无意间看到的一个框架、平台，今年1月份发布了1.0版本，并且很快就达到了2.0版本，[官网](https://nodejs.org)不断迭代版本，[社区](https://cnodejs.org/)也很活跃，做后端的朋友可以多关注一下。\n\n<!--more-->\n\n## Node.js概念\n\n>Node.js是一个Javascript运行环境(runtime)，发布于2009年5月，由RyanDahl开发，实质是对ChromeV8引擎进行了封装。Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。\n>V8引擎执行Javascript的速度非常快，性能非常好。Node.js是一个基于Chrome JavaScript运行时建立的平台，用于方便地搭建响应速度快、易于扩展的网络应用。Node.js使用事件驱动，非阻塞I/O模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。\n><div style=\"text-align: right;\">[直接引用百度百科](https://baike.baidu.com/item/node.js/7567977?fr=aladdin&fromid=11244313&fromtitle=nodejs)</div>\n\n## Node.js的优势\n\n- RESTful API；\n- 单线程；\n- 非阻塞IO；\n- V8虚拟机；\n- 事件驱动。\n\n说这么多，说的什么鬼，我也不懂啊\n\n## Node.js安装与配置\n\n这里以Windows演示一下Node.js的安装与配置：\n\n- 下载Node.js安装包(建议下载LTS版本)，进入[官网](https://nodejs.org/en/)，下载对应平台版本的安装包；\n- 安装Node.js；\n注意在安装时，记得把Add To Path，不然就要手动将Node.js安装目录和npm的目录添加到环境变量中了；\n打开Git Bash输入`node -v`测试node是否安装成功；\n再输入`npm -v`，测试是否npm是否安装成功；\n- 替换npm的源\n打开Git Bash，输入`npm install -g cnpm --registry=http://registry.npm.taobao.org`\n再输入`cnpm`，测试cnpm是否安装成功。\n\n## Node.js最常用命令\n由于cnpm是npm的镜像，所以两者的命令及参数是一模一样的，这里只说一下npm的命令操作...\n- node -v\n- node -h\n- npm i (i为install的简写) 安装模块到本目录\n- npm i -g (i为install的简写) 全局安装模块\n- npm un (un为uninstall的简写) 卸载本目录模块\n- npm un -g (un为uninstall的简写) 卸载本目录模块\n- npm list 列出安装的模块\n- npm update 更新当前目录下的所有模块\n\nNode.js升级\n```\nnpm install -g n\nn stable\n```\n\nnpm升级\n```\nnpm install npm -g\n```\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Node"],"categories":["languages"]},{"title":"Git 中级用户的25个提示","url":"/posts/2220897336/","content":"**超级好用的版本管理系统：**\n\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\n\n<!--more-->\n\n## 什么是Git\n<div style=\"text-align: center;\">![git log](https://coding.net/u/ibrucekong/p/images/git/raw/master/git-log.jpg)</div>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理Linux 内核开发而开发的一个开放源码的版本控制软件。</p>\n\n## 安装及基本知识\n\n### 安装后第一步\n\n安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息：\n\n```\n$ git config --global user.name \"Some One\"\n$ git config --global user.email \"someone@gmail.com\"\n```\n\n### Git是以指针为基础\n\n存储在 git 中的所有东西都包含在一个文件中。当你提交的时候，git 会创建一个包含提交消息和相关数据的文件（名称、邮件、日期/时间、上一次提交等等），并将其链接到一个树形文件。树形文件包含一个对象列表或者其它树。对象或二进制大数据对象([BLOB](http://en.wikipedia.org/wiki/Binary_large_object))是提交的真正内容（一个文件，如果你愿意，虽然文件名没有存储在对象中，但会存储在树中）。所有这些文件都以对象的 SHA-1 哈希为文件名进行存储。\n\n分支和标签只是一些文件，这些文件包含（基本上）一个指向提交的 SHA-1 哈希值。使用这些引用在灵活性和速度上均有大幅提升，创建一个新的分支就和创建一个文件一样简单，只是这个文件带有分支名称和一个包含指向提交（你从这个提交建立分支）的SHA-1哈希值。当然，当你使用 Git 命令行工具（或一个图形用户界面）时，你永远也不会这么做，但它就是这么简单。\n\n你可能已经听说过对 HEAD 的引用。它只是一个包含 SHA-1引用的文件，这个引用指向你当前的提交。如果你正在解决一个合并冲突问题，查看一下HEAD，你会发现，它与一个特定的分支或分支上的特定点无关，只和你现在的位置有关。\n\n所有的分支指针保存在 .git/refs/heads 目录下，HEAD 在 .git/HEAD 目录下，标签在 .git/refs/tags 目录下 - 你可以随意看看。\n\n### 两个Parents - 当然！\n\n当在日志文件中查看一个合并提交的消息时，你会看到两个 parents（与正常提交相比）。第一个parent 是你所在的分支，第二个 parents 是你并入的分支。\n\n### 合并冲突\n\n到目前为止，我确信你一定有一个合并冲突需要解决。通常情况下，通过编辑该文件，删除文件中的<<<<, ====, >>>>标记，然后保存你需要保留的代码就可以了。有时候，在任何变更之前查看代码都是一个值得推荐的做法，比如，在你对两个有冲突的分支采取行动之前。这是又一个命令：\n\n```\n$ git diff --merge\ndiff --cc dummy.rb  \nindex 5175dde,0c65895..4a00477  \n--- a/dummy.rb\n+++ b/dummy.rb\n@@@ -1,5 -1,5 +1,5 @@@\n  class MyFoo\n    def say\n-     puts \"Bonjour\"\n -    puts \"Hello world\"\n++    puts \"Annyong Haseyo\"\n    end\n  end\n```\n\n如果文件是二进制的，文件比较就不是那么容易了...你通常要做的是尝试每个版本的二进制文件，并决定使用哪一个（或者在二进制文件编辑器手动复制部分内容）。从一个特定分支下 pull 一个文件副本（如果你要合并主分支和分支132的话）：\n\n```\n$ git checkout master flash/foo.fla # or...\n$ git checkout feature132 flash/foo.fla\n$ # Then...\n$ git add flash/foo.fla\n```\n\n另一种方法是从 git 中查看这个文件 - 你能够以其他文件名的方式进行查看，然后将正确的文件（当你确定它是哪一个时）复制到正常的文件名中：\n\n```\n$ git show master:flash/foo.fla > master-foo.fla\n$ git show feature132:flash/foo.fla > feature132-foo.fla\n$ # Check out master-foo.fla and feature132-foo.fla\n$ # Let's say we decide that feature132's is correct\n$ rm flash/foo.fla\n$ mv feature132-foo.fla flash/foo.fla\n$ rm master-foo.fla\n$ git add flash/foo.fla\n```\n\n更新：感谢 Carl 在早先的的博客评论中给与的提醒，你实际上能使用 “git checkout —ours flash/foo.fla” 和 “git checkout —theirs flash/foo.fla” 检出一个特定的版本而不需要记住你要合并到哪一个分支。我个人更喜欢更明确些，但是你可以随便选择...\n\n在解决了合并冲突问题之后（就像我上面所做的那样），请记得将这个文件添加给索引。\n\n## 服务器、分支和标签\n\n### 远程服务器\n\nGit 最强大的功能之一是可以有一个以上的远程服务器（另一个事实，你总是可以运行一个本地仓库）。你不一定总是需要写访问权限，你可以从多个服务器中读取（用于合并），然后写到另一个服务器中。添加一个远程服务器很简单：\n\n```\n$ git remote add john git@github.com:johnsomeone/someproject.git\n```\n\n如果你想查看远程服务器的相关信息，你可以这样做：\n\n```\n# shows URLs of each remote server\n$ git remote -v \n\n# gives more details about each\n$ git remote show name\n```\n\n你可以查看本地分支和远程分支之间的差别：\n\n```\n$ git diff master..john/master\n```\n\n你也能查看不在远程分支上的 HEAD 的变化：\n\n```\n$ git log remote/branch..\n# Note: no final refspec after ..\n```\n\n### 标签\n\n在 Git 中存在两种类型的标签 - 一个轻量级标签和一个注解标签。记着第二个提示中说过 Git 是基于指针的，二者的区别很简单。一个轻量级标签无非是一个指向提交的具名指针。你可以改变它并指向另一个提交。一个注解标签是一个指向标签对象的具名指针，这个标签对象拥有自己的消息和历史。如果有需要，标签对象的消息可以采用 GPG 加密签名。\n\n创建两种类型的标签其实很容易（只是一个命令行选项的差异）\n\n```\n$ git tag to-be-tested\n$ git tag -a v1.1.0 # Prompts for a tag message\n```\n\n### 创建分支\n\n在 Git 中创建分支非常容易（闪电般的速度，因为它仅仅需要创建一个不到100字节的文件）。创建一个新分支并切换过去的通用写法是：\n\n```\n$ git branch feature132\n$ git checkout feature132\n```\n\n当然，如果你知道你要马上切换过去，你可以使用一条命令就能做到：\n\n```\n$ git checkout -b feature132\n```\n\n如果你要重命名一个本地分支，同样是件容易的事（长命令方式用来显示具体执行过程）：\n\n```\n$ git checkout -b twitter-experiment feature132\n$ git branch -d feature132\n```\n\n更新：或者你（就像 Brian Palmer 在博客文章评论中指出的那样）只使用 “git branch” 和 -m 选项就可以一步到位：\n\n```\n$ git branch -m twitter-experiment\n$ git branch -m feature132 twitter-experiment\n```\n\n### 合并分支\n\n在将来某个时候，你想要合并你的变更。有两种方式可以实现：\n\n```\n$ git checkout master\n$ git merge feature83 # Or...\n$ git rebase feature83\n```\n\nmerge 和 rebase 的区别在于，merge 试图解决变更而且创建一个融合后的新提交，而 rebase 则试图把自你上次在其他分支上的变化，在另一个分支的 HAED 上重现。但是，在你向远程服务器推送一个分支之后，不要进行 rebase 操作 - 这会引发混淆/问题。\n\n如果你不能确定哪些分支仍然有独立的工作在进行 - 以便你能知道你需要合并哪一个分支以及删除哪些分支，git branch 命令有两个选项可以帮助实现这一点：\n\n```\n# Shows branches that are all merged in to your current branch\n$ git branch --merged\n\n# Shows branches that are not merged in to your current branch\n$ git branch --no-merged\n```\n\n### 远程分支\n\n如果你有一个本地分支，你想让它出现在远程服务器上，你可以使用一个推送命令：\n\n```\n$ git push origin twitter-experiment:refs/heads/twitter-experiment\n# Where origin is our server name and twitter-experiment is the branch\n```\n\n更新：感谢 Erlend 在博客文章评论中提到的 - 这实际上和 git push origin twitter-experiment 达到的效果的一样，但是通过使用全部语法，你能看到你实际上在两端使用了不同的名字（你的本地名字可能是 add-ssl-support，而远程名字可能是 issue-1723）。\n\n如果你想删除一个远程服务器上的分支（请注意分支名称之前的冒号）：\n\n```\n$ git push origin :twitter-experiment\n```\n\n如果你想显示所有远程分支的状态，你能像这样查看它们：\n\n```\n$ git remote show origin\n```\n\n这可能会列出一些服务器上曾经有过但现在已不存在的分支。如果碰到这种情况，你可以很轻松地使用如下命令从本地检出并将其删除：\n\n```\n$ git remote prune\n```\n\n最后，如果你有一个远程分支，你想在本地进行跟踪它，通常的做法是：\n\n```\n$ git branch --track myfeature origin/myfeature\n$ git checkout myfeature\n```\n\n然而，如果你使用 -b 标识符去检出的话，新版的 Git 会自动建立跟踪：\n\n```\n$ git checkout -b myfeature origin/myfeature\n```\n\n`在临时存放区、索引和文件系统中保存内容`\n\n### 临时存放（Stashing）\n\n在Git中，你可以把当前的工作状态储存在一个临时的存储区域堆栈，然后重新加以利用。简单的案例如下：\n\n```\n$ git stash # Do something...\n$ git stash pop\n```\n\n很多人推荐使用 git stash apply 来代替 “pop”，然而如果你真这么做的话，你最终得到一个长长的毫无用处的储藏清单。如果对它进行清理，“pop” 只会把它从堆栈中删除。如果你已经使用了 git stash apply ，你可以使用如下命令从堆栈中删除最后一项：\n\n```\n$ git stash drop\n```\n\nGit 会基于当前的提交消息自动创建一个注释信息。如果你更喜欢使用一个自定义的消息（因为它可能和之前的提交无关）：\n\n```\n$ git stash save \"My stash message\"\n```\n\n如果你想从你的列表中（不必是最后一个）对一个特定的 stash 加以利用，你可以列出它们并像这样来使用它：\n```\n$ git stash list\n  stash@{0}: On master: Changed to German\n  stash@{1}: On master: Language is now Italian\n$ git stash apply stash@{1}\n```\n\n### 交互式添加\n\n在 Subversion 的世界里，你修改文件然后只是提交有变化的文件。而在 Git 的世界里，你在提交某些文件甚至某些补丁上有更多的控制权。为了提交某些文件或者文件的某些部分，你必须进入交互模式。\n\n```\n$ git add -i\n           staged     unstaged path\n\n\n*** Commands ***\n  1: status      2: update   3: revert   4: add untracked\n  5: patch      6: diff     7: quit     8: help\nWhat now>\n```\n\n这会让你进入一个基于交互式命令的菜单模式。你可以使用命令的数字符号或者加亮字符（如果你开启颜色高亮显示功能的话）进入对应模式，然后就是正常输入文件数的问题了（你可以使用像1或1-4或2,4,7这样的格式）。\n\n如果你想进入修补模式（交互模式下输入‘p’或‘5’ ），你也可以直接进入那个模式：\n\n```\n$ git add -p    \ndiff --git a/dummy.rb b/dummy.rb  \nindex 4a00477..f856fb0 100644  \n--- a/dummy.rb\n+++ b/dummy.rb\n@@ -1,5 +1,5 @@\n class MyFoo\n   def say\n-    puts \"Annyong Haseyo\"\n+    puts \"Guten Tag\"\n   end\n end\nStage this hunk [y,n,q,a,d,/,e,?]?\n```\n\n如你所见，在底部你得到一系列选项为选择去添加文件改变的部分，这个文件的所有变化等等。使用‘?’ 命令可以了解选不同选项的解释。\n\n### 存储/从文件系统检索\n\n一些项目（例如 Git 项目自身）直接在 Git 文件系统中存储额外的文件而不必是检入文件。\n\n让我们开始在 Git 中存储一个任意文件：\n\n```\n$ echo \"Foo\" | git hash-object -w --stdin\n51fc03a9bb365fae74fd2bf66517b30bf48020cb\n```\n\n此时，该文件对象已在数据库中，但是如果你不设置（一些东西）指向那个文件对象，它将被作为垃圾而回收。最简单的方法是标记它：\n\n```\n$ git tag myfile 51fc03a9bb365fae74fd2bf66517b30bf48020cb\n```\n\n既然在这里我们已经标记了 myfile。当我们需要获取该文件时，我们可以这样做：\n\n```\n$ git cat-file blob myfile\n```\n\n程序员可能经常用到的工具文件（密码、GPG 密钥、等等），不需要每次都检出到磁盘上（特别是在生产环境下），这种方法非常有效。\n\n## 日志记录\n\n### 查看日志\n\n如果你不使用‘git log’查看最近提交历史的话，你就不能长时间顺利地使用Git。但是，也存在一些如何更好使用它的建议。例如，你可以查看每次提交中改变的一个补丁：\n\n```\n$ git log -p\n```\n\n或者你可以只是查看一个哪些文件有所更改的概述：\n\n```\n$ git log --stat\n```\n\n你可以在一行中设置一个不错的别名，用于显示简短的提交和漂亮的带有消息的分支图（像 gitk，但在命令行上）：\n\n```\n$ git config --global alias.lol \"log --pretty=oneline --abbrev-commit --graph --decorate\"\n$ git lol\n* 4d2409a (master) Oops, meant that to be in Korean\n* 169b845 Hello world\n```\n\n### 检索日志\n\n如果你想在日志中查询一个特定作者，你可以这样指定：\n\n```\n$ git log --author=Andy\n```\n\n更新：感谢 Johannes 的评论，我终于化解了一部分困惑。\n或者如果你有一个搜索词出现在提交消息中：\n\n```\n$ git log --grep=\"Something in the message\"\n```\n\n还有一个功能更强大的叫 pickaxe 的命令，它可以查找条目用来添加或删除一个特定的内容（也就是，当它第一次出现或被删除的时候）。这样你就可以知道何时增加了一行（但是如果那一行中的字符随后被改变，你将无从得知）：\n\n```\n$ git log -S \"TODO: Check for admin status\"\n```\n\n如果你改变一个特定的文件会怎么样呢，例如 lib/foo.rb\n\n```\n$ git log lib/foo.rb\n```\n\n比如说你有一个 feature/132 分支和一个 feature/145 分支，你想查看在这些分支但却不在主分支上的提交（备注：^ 代表非）：\n\n```\n$ git log feature/132 feature/145 ^master\n```\n\n你也可以使用 ActiveSupport 风格的日期缩小日期范围：\n\n```\n$ git log --since=2.months.ago --until=1.day.ago\n```\n\n它默认使用 OR 模式来组合查询，但是你也可以很轻松地改为 AND 模式（如果你的查询项不止一个的话）\n\n```\n$ git log --since=2.months.ago --until=1.day.ago --author=andy -S \"something\" --all-match\n```\n\n### 选择查看/修改的版本\n\n当引用一个修订版本时，你有许多选项可以选择，当然，这取决于你对此功能的了解程度：\n\n```\n$ git show 12a86bc38 # By revision\n$ git show v1.0.1 # By tag\n$ git show feature132 # By branch name\n$ git show 12a86bc38^ # Parent of a commit\n$ git show 12a86bc38~2 # Grandparent of a commit\n$ git show feature132@{yesterday} # Time relative\n$ git show feature132@{2.hours.ago} # Time relative\n```\n\n请注意，和上一节有所不同，在行尾的脱字符表示提交的 parent - 行首的脱字符则表示不在这个分支上。\n\n### 选择一个范围\n\n最简单的方法是这样来用：\n\n```\n$ git log origin/master..new\n# [old]..[new] - everything you haven't pushed yet\n```\n\n你也可以删除 [new]，这将使用当前的 HEAD。\n\n`时间回退和错误修复`\n\n### 重置更改\n\n如果你还没有提交一个更改，你可以很容易地重置它：\n\n```\n$ git reset HEAD lib/foo.rb\n```\n\n通常使用‘unstage’作为别名比较好，因为它不是那么显而易见。\n\n```\n$ git config --global alias.unstage \"reset HEAD\"\n$ git unstage lib/foo.rb\n```\n\n如果你已经提交了文件，你可以做两件事情 - 如果是最后一次提交，你可以这样来修改：\n\n```\n$ git commit --amend\n```\n\n这将回滚到最后一次提交，让你的工作副本回到变化存储在暂存区的状态，你可以编辑提交消息准备下一次提交。\n如果你的提交不止一次，并且只想完全回滚它们，你可以重置分支回到之前的时间点。\n\n```\n$ git checkout feature132\n$ git reset --hard HEAD~2\n```\n\n如果你真的想把分支指向一个完全不同的 SHA-1（也许你把一个分支的 HEAD 指向另一个分支，或者进一步提交），你可以按照以下方式去做：\n\n```\n$ git checkout FOO\n$ git reset --hard SHA\n```\n\n实际上还有一种更便捷的方式（因为它不会先将你的工作副本变回最初 FOO 状态，然后再指向 SHA）：\n\n```\n$ git update-ref refs/heads/FOO SHA\n```\n\n### 提交到错误的分支\n\n好吧，让我们假设你提交到主分支，但应该已经创建了一个叫做 experimental 的主题分支。为了移除这些变化，你可以在当前点创建一个分支，回退 HEAD，然后检出新的分支：\n\n```\n$ git branch experimental   # Creates a pointer to the current master state\n$ git reset --hard master~3 # Moves the master branch pointer back to 3 revisions ago\n$ git checkout experimental\n```\n\n如果你已经在一个分支的一个分支的一个分支等上面做了些变更，这将会更复杂。然后你需要做的就是在这个分支上将其变更 rebase 到另一个的地方：\n\n```\n$ git branch newtopic STARTPOINT\n$ git rebase oldtopic --onto newtopic\n```\n\n### 交互式 rebasing\n\n这是一个很酷的特性，我之前已看过演示，但当时没有真正搞明白，现在来看其实很简单。比方说，你已做了3次提交，但是你想对它们进行重新排序或者编辑（或者合并它们）：\n\n```\n$ git rebase -i master~3\n```\n\n然后你将编辑器打开。你所要做的就是修改 “pick/squash/edit 的指令来进行如何提交，然后保存/退出。在编辑之后，你可以使用`git rebase —continue`让你的每一个指令一个一个进行。\n\n如果你选择编辑一个文件，这会让你停留在你提交时的状态，因此你需要使用`git commit —amend`对它进行编辑。\n\n备注：在 REBASE 过程中不要进行提交工作 - 只能添加然后使用 —continue, —skip or —abort 选项。\n\n### 清理\n\n如果你已经提交了一些内容到你的分支中（也许你是从SVN中的旧代码库导入的），你想从历史中删除掉所有的已提交内容：\n\n```\n$ git filter-branch --tree-filter 'rm -f *.class' HEAD\n```\n\n如果你已经向远程服务器推送过代码，但自那之后提交的都是一些垃圾，在推送之前你可以在本地系统上执行这样的操作：\n\n```\n$ git filter-branch --tree-filter 'rm -f *.class' origin/master..HEAD\n```\n`各种各样的提示`\n\n### 之前你看过的引用\n\n如果你知道你之前已经查看过一个 SHA-1，但是你已经做了一些重置/回退工作，你可以使用 reflog 命令去查看你最近看过的 SHA-1:\n\n```\n$ git reflog\n$ git log -g # Same as above, but shows in 'log' format\n```\n\n### 分支命名\n\n一个可爱的小提示 - 请记住，分支的名字并不局限于 a-z 和 0-9 这些字符。名字中可以使用 / 和 . 来伪装命名空间或者版本号，例如：\n\n```\n$ # Generate a changelog of Release 132\n$ git shortlog release/132 ^release/131\n$ # Tag this as v1.0.1\n$ git tag v1.0.1 release/132\n```\n\n### 寻找谁是始作俑者\n\n寻找谁更改了一个文件中的一行代码经常会用到。简单命令如下：\n\n```\n$ git blame FILE\n```\n\n有时更改来自于前一个文件（如果你已经合并了两个文件，或者你已经移动了一个函数），因此你可以这样用：\n\n```\n$ # shows which file names the content came from\n$ git blame -C FILE\n```\n\n有时通过向前或向后点击来进行变化跟踪，这是很好的方法。有一个内置的 GUI 程序专门为此设计：\n\n```\n$ git gui blame FILE\n```\n\n### 数据库维护\n\nGit 通常不需要大量维护，它基本上可以自我维护。然而，你可以使用如下命令查看数据库统计信息：\n\n```\n$ git count-objects -v\n```\n\n如果数值很高，你可以选择使用垃圾回收你的重复内容。这不会影响推送或者其它用户，但却可以让你的命令运行更快且占用更少空间：\n\n```\n$ git gc\n```\n\n经常运行一致性检查也是值得推荐的做法：\n\n```\n$ git fsck --full\n```\n\n你也可以在行尾添加一个 —auto 参数（如果你频繁运行它，或者在你的服务器上每日从 crontab 中运行它），如果统计数据表明必须进行要进行一致性检查，只要 fsck 命令就行。\n\n如果检查 “dangling” 或 “unreachable” 的结果一切正常，这经常是由于回退 HEAD 或 rebasing的结果。如果检查“missing” 或 “sha1 mismatch” 出了问题...寻求专业帮助吧！\n\n### 恢复一个丢失的分支\n\n如果你使用 -D 选项删除了一个分支 experimental，你可以重新创建它：\n\n```\n$ git branch experimental SHA1_OF_HASH\n```\n\n你可以使用`git reflog`来发现一个 SHA-1 哈希值，如果你近期访问过它的话。\n\n另一种方法是使用`git fsck —lost-found`。一个悬空的提交就是一个`lost HEAD`（它只会是一个已删除分支的 HEAD，因为当一个 HEAD^ 被 HEAD 引用时，它就没有悬空）\n\n原文链接 : [25 Tips for Intermediate Git Users](https://www.andyjeffries.co.uk/25-tips-for-intermediate-git-users/)\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["版本管理","Git"],"categories":["languages"]},{"title":"控制台，终端，tty，shell等概念的区别","url":"/posts/1500121752/","content":"**带你走进终端世界：**\n\n控制台程序是为了兼容DOS程序而设立的，这种程序的执行就好像在一个DOS窗口中执行一样，没有自己的界面。\n\n<!--more-->\n\n使用linux已经有一段时间，却一直弄不明白这几个概念之间的区别。虽然一直在用，但是很多概念都感觉模糊不清，这样不上不下的状态实在令人不爽。下面就澄清一下这些概念。\n\n这些概念本身有着非常浓厚的历史气息，随着时代的发展，他们的含义也在发生改变，它们有些已经失去了最初的含义，但是它们的名字却被保留了下来。\n\n## 控制台(Console)\n\n控制台(Console)是物理设备，用于输入输出，它直接连接在计算机上，是计算机系统的一部分。计算机输出的信息会显示在控制台上，例如BIOS的输出，内核的输出。\n\n## 终端(Terminal)\n\n终端(Terminal)也是一台物理设备，只用于输入输出，本身没有强大的计算能力。一台计算机只有一个控制台，在计算资源紧张的时代，人们想共享一台计算机，可以通过终端连接到计算机上，将指令输入终端，终端传送给计算机，计算机完成指令后，将输出传送给终端，终端将结果显示给用户。\n\n## 虚拟控制台(Virtual Console)，虚拟终端(Virtual Terminal)\n\n虚拟控制台(Virtual Console)和虚拟终端是一样的。我们只有一台终端（物理设备），这是我们与计算机之间的用户接口。假如有一天，我们想拥有多个用户接口，那么，一方面我们可以增加终端数目（物理设备），另一方面，还可以在同一台终端（物理设备）上虚拟出多个终端，它们之间互相不影响，至少看起来互相不影响。这些终端就是虚拟终端。\n\n在Ubuntu中，我们按下Ctrl+Alt+Fx时，会进入第x个虚拟终端，一共有七个虚拟终端，其中第七个虚拟终端，就是我们默认使用的图形用户界面。\n\n## 终端模拟器(Terminal Emulator)\n\n我们知道，终端是一种物理设备，而终端模拟器(Terminal Emulator)，是一个程序，这些程序用来模拟物理终端。图形用户界面中的终端模拟器一般称为终端窗口(Terminal Window)，我们在Ubuntu下打开的gnome-terminal就属于此类。\n\n## tty\n\ntty的全称是TeleTYpewriter，这就是早期的终端（物理设备），它们用于向计算机发送数据，并将计算机的返回结果打印出来。显示器出现后，终端不再将结果打印出来，而是显示在显示器上。但是tty的名字还是保留了下来。\n\n在Ubuntu中，我们按下Ctrl+Alt+F1时，会进入第1个虚拟终端，你可以看到屏幕上方显示的tty1。\n\n## shell\n\nshell 和之前说的几个概念截然不同，之前的几个概念都是与计算机的输入输出相关的，而shell是和内核相关的。内核为上层的应用提供了很多服务，shell在内核的上层，在应用程序的下层。例如，你写了一个 hello world 程序，你并不用显式地创建一个进程来运行你的程序，你把写好的程序交给shell就行了，由shell负责为你的程序创建进程。\n\n我们在终端模拟器中输入命令时，终端模拟器本身并不解释执行这些命令，它只负责输入输出，真正解释执行这些命令的，是shell。\n\n我们平时使用的sh, bash, csh是shell的不同实现。\n\n>**sh:** \n>sh这个概念本身就有岐义，它可以指shell程序的名字，也代表了shell的实现。\n>Thompson shell是第一个Unix shell，由 Ken Thompso于1971年在Unix第一版本中引入，shell的程序名即为sh。Bourne shell作为Thompson shell的替代，由 Stephen Bourne于1977年在Unix第七版中引入，它的程序名也是sh。Bourne shell不仅仅是一个命令解释器，更作为一种编程语言，提供了Thompson shell不具备的程序控制功能，并随着 Brian W. Kernighan 和 Rob Pike 的 The UNIX Programming Environment的出版而名声大噪。\n>\n>**csh: **\n>csh全称为 C Shell，由 Bill Joy在70年代晚期完成，那时候他还是加州伯克利大学的研究生。tcsh是csh的升级版。与sh不同，csh的shell脚本，语法接近于C_language。\n>\n>**bash: **\n>bash是由 Brian Fox为GNU项目开发的自由软件，作为Bourne shell的替代品，于1989年发布。是Linux和Mac OS X的默认shell。bash的命令语法是Bourne shell命令语法的超集，从ksh和csh借鉴了一些思想。\n\n好了，就写到这里，上面的内容是我参考维基百科后写下的，`不保证完全正确`，下面还提供了一些资料，如果有兴趣可以阅读一下。\n\n## 扩展阅读\n\n>* [What is the exact difference between a 'terminal', a 'shell', a 'tty' and a 'console'?](http://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con)\n>* [shell，bash,zsh,console,terminal到底是什么意思，它们之间又是什么关系？](http://www.linuxsir.org/bbs/thread362001.html?pageon=1#2059206)\n>* [shell、控制台、终端的区别](http://blog.csdn.net/caomiao2006/article/details/8791775)\n>* [Why is a virtual terminal “virtual”, and what/why/where is the “real” terminal?](http://askubuntu.com/questions/14284/why-is-a-virtual-terminal-virtual-and-what-why-where-is-the-real-terminal)\n\n**参考自:**[Minixalpha Blog](http://minixalpha.github.io/%E5%B7%A5%E5%85%B7/2014/02/28/terminal-shell.html)\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["控制台","终端"],"categories":["tools"]},{"title":"如何编写高质量的程序","url":"/posts/3490671754/","content":"**学习编程：**\n\n学习任何编程语言都会有一个基本的过程，开始的时候学习基本的语法，然后学习各种库，框架，开始做各种项目。\n\n<!--more-->\n\n## 如何编写高质量的程序\n\n学习任何编程语言都会有一个基本的过程，开始的时候学习基本的语法，然后学习各种库，框架，开始做各种项目。在做项目的过程中，随着代码量的增加，我们会渐渐感到失去对程序的掌控能力，bug开始增加，牵一发而动全身，顾此失彼。这充分说明了编写高质量程序的重要性，这里的“高质量”主要指程序的正确性，可读性，可维护性。\n\n## 什么是高质量的程序\n\n**正确性**\n\n程序正确性的重要程度无需多言，尤其在一些特殊领域，例如芯片制造业，航天业，武器制造业，对程序正确性往往有着极其严格的要求，因为一旦程序出错，代价往往是巨大的。在这些领域，需要使用形式化方法(formal methods)来自动验证程序的正确性，也就是说你需要证明程序的正确性，而不仅仅保证程序在大多数情况下是正确的。在其它领域，对正确性没有这么高要求，形式化方法也不适用，但是我们还是需要使用其它手段，例如测试，code review等等来保证软件的正确性。\n\n**可读性**\n\n可读性可以帮助程序作者理清思路，思路清晰后，程序不容易出错。另外，其它程序员在维护你的代码时，更容易理解你的意思，方便修改bug，方便扩展。\n\n不要浪费自己的时间，更不要浪费别人的时间。\n\n**可维护性**\n\n这里的可维护性主要指程序应对变化的能力。程序在完成基本功能后，可能会发生各种改变：用户需求变了，性能达不到要求需要重新实现算法，等等。一旦程序的一个点发生改变，其它点如果也需要同时手动改变，那么程序会变的不可控制，出bug的机会会增加。想像一下，我们的程序是一个盒子，在添加新功能时，如果只需要把新模块插到一个地方，新模块就可以被系统使用，这样的程序可维护性是很高的。但是如果添加新功能时，需要把原来的程序盒子拆开，其它模块也需要相应修改，才能加入新模块，这样的程序可维护性就很差。\n\n## 提高程序质量的重要措施\n\n**测试**\n\n为什么强调先编写测试用例，再实现程序？先编写测试用例的意义在于，让编写程序的人对程序本身有更好的理解。因为你首先得明白什么样的程序是正确的，然后才能写出正确的程序。测试用例其实是对程序正确性的一种描述。\n\n为什么强调自动化测试，而不是手动测试？因为自动化测试可以增加测试的便捷度，而人们通常会更多地使用那些便捷度高的东西。我在做个人项目的时候就发现，在编写了自动测试的脚本后，我每改动一点程序，就会自动运行一下脚本，在此之前，我明知道测试很重要，但是还是不会测试的如此频繁。这样的好处是可以方便定位bug，否则在系统经过了大量改动之后，出了bug都不知道可能在哪里。\n\n在对程序进行重构时，很重要的一点就在于，一定要先写好测试用例，然后每改动一点，就自动测试一下，保证程序始终保持在可控状态。\n\n**良好的编程风格**\n\n良好的编程风格，可以增强程序的可读性，一个结构清晰的程序，你会更容易从中发现错误。另一方面，当程序发生变化时，很可能引入新的bug，良好的编程风格可以减少这种bug的出现。下面是与编程风格相关的一些措施。\n\n>**风格指南:**\n>找一份你使用的编程语言的风格指南，例如Google的编程语言风格指南系列，Python的PEP8，并一直遵守这份指南的内容，如果有自动化工具帮助你保持这种风格，那再好不过。\n>\n>**最佳实践:**\n>寻找你所使用语言的最佳实践，他们可读性强，经过了大量实践的考验，被广泛接受，所以尽可能多地使用他们。\n>\n>**起一个好名字:**\n>变量，函数名，类名，都需要一个好名字。程序本身是对解决方案的一种描述，一个好的名字会增强这种描述性，也会让你的思维集中于解决方案，同时让其它人更容易理解你的解决方案。\n>\n>**不要直接使用常量:**\n>在程序中直接使用的常量，一般被称为 Magic Numbers， 一方面它不利于其它程序员对程序的理解，因为没有人知道这个常量代表什么。另一方面，多个常量之间可能是有关系的，直接使用常量根本反应不出这种关系。\n>\n>**同一变量名不要有多种含义:**\n>首先这种做法降低了可读性，一个变量前面一个含义，后面一个含义，这会给阅读程序的人带来困扰。\n>\n>**尽可能保证变量作用域小:**\n>尽量减少变量定义的点与变量最后一次使用的点之间的跨度，这样可以使变量与其相关代码变得紧凑，提高可读性，不用在使用变量时再去很多的地方查看其它引用。\n>\n>**保证函数短小精悍:**\n>过长的函数会让读者陷入细节的泥潭，还需要前后来回看才能明白前面一大段和后面一大段代码的关系。将函数分解，然后给函数起一个好名字，读者马上就能明白这段代码在做什么。\n\n## 提高应变能力\n\n>程序应对变化的能力强，可扩展性就强，也更容易在变化时保证正确性，这样的程序可维护性强。下面是一些提高程序应变能力的措施。\n>\n>**不要使用常量:**\n>不要使用常量的另一个原因在于常量可能变化，如果程序中多次引入了这个常量，那么一旦这个常量要发生变化，就需要同时改动许多地方，这时候，如果有些地方没有改，就会使程序不一致，可能引入bug。\n>\n>**同一变量名不要有多种含义:**\n>同一变量名不要有多种含义另一个原因在于，多种含义之间可能会相互影响，第一次写程序时你可能记得这些影响，但是以后对程序进行改动的时候，你可能就忘记了。例如函数内一段代码执行后，索引i 的值等于一个长度，但是这段代码后，你没有将i赋值给另一个变量len，而是直接使用它。等过一段时间后，你或者其它人修改这段程序时，很可能忘了这段代码执行后i的值需要等于一个长度，因为这是一种隐式的约定，所以很容易被忽视。\n>\n>**尽可能保证变量作用域小:**\n>保证变量作用域小也有利于重构。当一个函数变得很长时，你可能需要将它分解成多个函数，这时候，如果变量跨度小，就可以很方便地提取函数，不用来回查找与此函数相关的变量的引用。\n>\n>**减少代码重复:**\n>如果有一段代码在很多地方重复，这就告诉你，需要把他们提取成一个函数。因为代码的重复意味着这是一块独立的逻辑，独立的逻辑可以抽象成一个函数。另一方面，一旦这段逻辑需要发生变化，只需要修改这个函数就可以了，不需要把所有地方都手动修改一遍。\n>\n>**数据驱动:**\n>数据驱动的意思是用数据表示来代替程序逻辑。例如，我们需要一个程序，判断某个月有几天，在实现时，最好用一个数组表示各个月的天数，需要哪个月直接查询就好，而不要使用大量的if语句来作逻辑判断。这只是一个小例子，它提醒我们，如果程序中含有大量判断语句，就应该想一想，能不能用数据来驱动逻辑，这样需要修改的时候，我们直接修改数据就好，而不用修改程序逻辑。\n\n我曾经接手过一个项目，这个项目其实是一个工具集，根据用户的选择，调用不同的工具。原始的代码里，就使用了大量if语句，并且每个工具其实调用方式和代码都很相似。这样，我每次添加新工具时，就需要找到多个if语句块，作相应修改。如果用数据驱动的话，我们完全可以去掉这些if语句，在用户的选择与工具之间建立对应关系，这样每当新添加工具时，只需要把工具加到系统里，系统会根据这个表直接找到这个工具。这其实和之前举的盒子的例子很相似，添加新工具时，只需要把工具插到盒子上的槽上，根本不用打开盒子。这就大大提高了程序的可扩展性。\n\n## 控制复杂度\n\n要保证软件的高质量，很重要的一方面在于控制复杂度。控制复杂度的一个很重要的手段在于分解复杂的事物。我们之所以觉得一个事物复杂，是因为同一时间需要关心的事情太多，把复杂事物分解后，每次我们只需要关心很少的事情，这样就控制住了复杂度。\n\n>不要使函数或类过大\n>如果一个函数或类过大，他们会变得过分复杂，你同一时间需要关心许多细节。将函数或类变小之后，你的思维在一段时间内可以集中在同一个抽象层次，而不必过于深入其细节，这样更容易发现程序中的缺陷，因为你每次只需要关心很少的事情。在最高层，你只需要关心模块之间的关系，关心算法的流程，不必关心模块内部的事情。在最低层，你只需要关心一个模块内部的事情，而不必关心其它事情。\n>\n>不要使函数参数过多\n>函数参数过多可能说明这个函数负责了太多的事情，你需要将这个函数分解。另一方面，你需要从逻辑上考虑，这些参数是不是一个整体，如果是一个整体，那么直接传过来一个结构体，或者传过来一个对象，是不是更合适？\n>\n>不要使抽象层次过多\n>如果一个函数或类被分解为过多的抽象层次，在模块内部，你确实只需要关心很小的事情，但是这时候，由于模块过多，抽象层次过深，他们之间的关系又使复杂度增长起来。\n\n## 使用自动化工具\n\n自动化工具迫使我们养成良好的编程习惯，而且不容易出错。再次强调:\n\n`工具越是使用方便，你越会频繁使用它。`\n所以，尽可能地让你的工具使用便捷。 \n例如，使用一些静态检测工具在编辑时自动帮助你检测程序的不良风格；使用重构工具帮助你重构；使用自动化测试工具在保存时自动运行测试等等。\n\n## 注意事项\n\n没有什么事情是一成不变的，所有的法则都需要考虑具体的情况。如果你要用一个法则，需要真正明白自己为什么要用，需要去权衡，而不要为了能用上这个法则而生搬硬套。\n\n好好问问自己：\n\n>* 变化真的存在么?\n* 真的需要抽象么？\n* 真的需要面向对象么？\n* 真的xxx么？\n\n## 参考资料\n\n这篇文章是我这段时间阅读过一些书后的想法，书目有:\n\n>* 代码大全(Code Complete)\n* 重构——改善既有代码的设计(Refactoring Improving the Design of Existing Code)\n* 程序设计实践(The Proactice of Programming)\n\n在阅读这些书的同时，我还在维护其它人的代码，做自己的个人项目。在阅读的过程中，我会不断地想到我做的项目哪里有问题，可以用书中提到的方法去修改，因此印象深刻。这些书单纯读也非常有好处，但是如果可以结合到自己的项目中，会有更大裨益。因为只有产生了强烈的共鸣，才能保证真正理解了一个东西。\n\n上面提到的一些措施，都是我遇到过的，所以印象比较深刻，这几本书中还有大量提高程序质量的方法，我这里只是一个引子，希望给有心人打开一扇窗户。\n\n原文链接 : [Minixalpha Blog](http://minixalpha.github.io/%E6%80%9D%E6%83%B3/2014/01/13/write_high_quality_program.html)\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["编程语言","心得"],"categories":["tips"]},{"title":"Markdown学习入门","url":"/posts/417703024/","content":"\n**锋利的Markdown：**\n\n当前很多博客、论坛都采用Markdown作为发文的首选编辑器，Markdown语言使用起来语法简单、易上手，利于格式排版，而且还易于阅读。\n\n<!--more-->\n\n## 什么是 Markdown\n&emsp;&emsp;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。\n\n&emsp;&emsp;Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在换行等细节上也有改动。\n\n## 为什么使用 Markdown\n\n>- 语法简单、易于上手\n- 格式排版方便，效率高\n- 看上去不错，易于阅读\n- 既然看上去不错，为什么不去试试呢~~~\n\n## 如何使用 Markdonw\n\n### 标题级别\n\n**显示效果：**\n\n><span style=\"font-size: 40px\">一级标题</span>\n<span style=\"font-size: 30px\">二级标题</span>\n<span style=\"font-size: 20px\">三级标题</span>\n\n**代码演示：**\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n```\n\n### 列表\n\n**显示效果：**\n\n>* 列表一\n* 列表二\n* 列表三\n\n**代码演示：**\n\n```\n* 列表一\n* 列表二\n* 列表三\n```\n\n### 引用\n\n**显示效果：**\n\n>来试试`Markdown`吧\n\n**代码演示：**\n\n```\n来试试`Markdown`吧\n```\n\n### 代码块引用\n\n**显示效果：**\n\n>def hello(): \nprint 'hello, world'\n\n**代码演示：**\n\n```\n```python\ndef hello(): \nprint 'hello, world'\n``` ```\n\n### 文字引用\n\n**显示效果：**\n\n> 春 眠 不 觉 晓，\n> 处 处 闻 啼 鸟。\n> 夜 来 风 雨 声， \n> 花 落 知 多 少。\n\n**代码演示：**\n\n```\n> 春 眠 不 觉 晓，\n> 处 处 闻 啼 鸟。\n> 夜 来 风 雨 声， \n> 花 落 知 多 少。\n```\n\n\n### 文字\n\n* 斜体\n\n**显示效果：**\n\n这是一个*斜体*\n\n\n**代码演示：**\n\n```\n这是一个*斜体*\n```\n\n* 粗体\n\n**显示效果：**\n\n这是一个**粗体**\n\n\n**代码演示：**\n\n```\n这是一个**粗体**\n```\n\n### 链接\n\n* 网页链接\n\n**显示效果：**\n\n参见Wiki词条[markdown](http://zh.wikipedia.org/wiki/Markdown)\n\n**代码演示：**\n\n```\n参见Wiki词条[Markdown](http://zh.wikipedia.org/wiki/Markdown)\n```\n\n* 图片\n\n**显示效果：**\n\n<div style=\"text-align: center;\">\n![Wikipedia_logo](https://coding.net/u/ibrucekong/p/images/git/raw/master/Wikipedia-logo.png)\n</div>\n\n**代码演示：**\n\n```\n![Wikipedia_logo](https://coding.net/u/ibrucekong/p/images/git/raw/master/Wikipedia-logo.png)\n```\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Markdown","写作"],"categories":["languages"]},{"title":"Android NDK学习入门教程","url":"/posts/1191879354/","content":"\n**高效的Android NDK开发：**\n\n为了开发的APK更加安全，防止其反编译；为了利用更高效的C/C++库，提高运行速度；为了更好的移植你的APP，应用在多平台上，请跟我一起使用Android NDK吧！\n\n<!--more-->\n\n&emsp;&emsp;Android的NDK开发入门指南.首先说为什么写Android项目要用到NDK开发，这里简单介绍一下其中优点：使用Android NDK主要就是为了提升应用的性能,对于那些对性能要求比较高的app 而言可以使用Android NDK,同时NDK绕过了Android的虚拟机的限制,可以使用一些更加底层的方法或是权限,但是使用Android NDK无论设计的多好,都会增加app的复杂性。\n\n&emsp;&emsp;但是这里我们只是单纯的说一下怎么通过Android进行NDK编程，而不去探讨更深层次的内容，创建一个Android NDK项目一般遵循一下步骤：\n\n## 系统环境\n\n>- Version : 1.0\n- Development platform : Android Studio 1.4 preview2\n- Gradle Version : 2.5\n- Gradle Plugin Version : 1.3.1\n\n## 简介\n\n> 1.创建一个空项目;\n2.在配置<code>NDK</code>路径;\n3.在入口<code>Activity</code>中定义一个<code>native</code>方法;\n4.利用<code>javah</code>生成<code>c</code>的头文件;\n5.在<code>jni</code>目录下新建一个<code>c</code>文件;\n6.引用<code>so</code>文件（没看到<code>so</code>文件）;\n7.加载<code>so</code>文件;\n8.配置布局文件和入口文件。\n\n## 功能介绍\n\n创建一个空的<code>project</code>；\n在<code>local.properties</code>中配置<code>NDK</code>路径：\n\n```groovy\nndk.dir=D\\:\\\\ComSoftwares\\\\android-ndk\nsdk.dir=D\\:\\\\ComSoftwares\\\\android-sdk\n```\n  \n在入口<code>Activity</code>中定义一个<code>native</code>方法:\n\n```java\npublic native String getStringFromNative();\n```\n\n利用<code>javah</code>生成<code>c</code>文件：\n&emsp;&emsp;根据项目路径和编译环境写出下面功能命令行，\n\n```\njavah -d jni -classpath D:\\ComSoftwares\\android-sdk\\platforms\\android-22\\android.jar;..\\..\\build\\intermediates\\classes\\debug com.ndktest.MainActivity\n```\n&emsp;&emsp;在Android Studio中的Terminal控制台中先用<code>cd ../../</code>返回到前两级文件夹，粘贴上面的长串代码，回车执行。会在<code>jni</code>中生成相应的头文件:<code>com_ndktest_MainActivity.h</code>.\n&emsp;&emsp;打开<code>com_ndktest_MainActivity.h</code>可以看到：\n\n```c\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class com_ndktest_MainActivity */\n#ifndef _Included_com_ndktest_MainActivity\n#define _Included_com_ndktest_MainActivity\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#undef com_ndktest_MainActivity_BIND_ABOVE_CLIENT\n#define com_ndktest_MainActivity_BIND_ABOVE_CLIENT 8L\n#undef com_ndktest_MainActivity_BIND_ADJUST_WITH_ACTIVITY\n#define com_ndktest_MainActivity_BIND_ADJUST_WITH_ACTIVITY 128L\n#undef com_ndktest_MainActivity_BIND_ALLOW_OOM_MANAGEMENT\n#define com_ndktest_MainActivity_BIND_ALLOW_OOM_MANAGEMENT 16L\n#undef com_ndktest_MainActivity_BIND_AUTO_CREATE\n#define com_ndktest_MainActivity_BIND_AUTO_CREATE 1L\n#undef com_ndktest_MainActivity_BIND_DEBUG_UNBIND\n#define com_ndktest_MainActivity_BIND_DEBUG_UNBIND 2L\n#undef com_ndktest_MainActivity_BIND_IMPORTANT\n#define com_ndktest_MainActivity_BIND_IMPORTANT 64L\n#undef com_ndktest_MainActivity_BIND_NOT_FOREGROUND\n#define com_ndktest_MainActivity_BIND_NOT_FOREGROUND 4L\n#undef com_ndktest_MainActivity_BIND_WAIVE_PRIORITY\n#define com_ndktest_MainActivity_BIND_WAIVE_PRIORITY 32L\n#undef com_ndktest_MainActivity_CONTEXT_IGNORE_SECURITY\n#define com_ndktest_MainActivity_CONTEXT_IGNORE_SECURITY 2L\n#undef com_ndktest_MainActivity_CONTEXT_INCLUDE_CODE\n#define com_ndktest_MainActivity_CONTEXT_INCLUDE_CODE 1L\n#undef com_ndktest_MainActivity_CONTEXT_RESTRICTED\n#define com_ndktest_MainActivity_CONTEXT_RESTRICTED 4L\n#undef com_ndktest_MainActivity_MODE_APPEND\n#define com_ndktest_MainActivity_MODE_APPEND 32768L\n#undef com_ndktest_MainActivity_MODE_ENABLE_WRITE_AHEAD_LOGGING\n#define com_ndktest_MainActivity_MODE_ENABLE_WRITE_AHEAD_LOGGING 8L\n#undef com_ndktest_MainActivity_MODE_MULTI_PROCESS\n#define com_ndktest_MainActivity_MODE_MULTI_PROCESS 4L\n#undef com_ndktest_MainActivity_MODE_PRIVATE\n#define com_ndktest_MainActivity_MODE_PRIVATE 0L\n#undef com_ndktest_MainActivity_MODE_WORLD_READABLE\n#define com_ndktest_MainActivity_MODE_WORLD_READABLE 1L\n#undef com_ndktest_MainActivity_MODE_WORLD_WRITEABLE\n#define com_ndktest_MainActivity_MODE_WORLD_WRITEABLE 2L\n#undef com_ndktest_MainActivity_DEFAULT_KEYS_DIALER\n#define com_ndktest_MainActivity_DEFAULT_KEYS_DIALER 1L\n#undef com_ndktest_MainActivity_DEFAULT_KEYS_DISABLE\n#define com_ndktest_MainActivity_DEFAULT_KEYS_DISABLE 0L\n#undef com_ndktest_MainActivity_DEFAULT_KEYS_SEARCH_GLOBAL\n#define com_ndktest_MainActivity_DEFAULT_KEYS_SEARCH_GLOBAL 4L\n#undef com_ndktest_MainActivity_DEFAULT_KEYS_SEARCH_LOCAL\n#define com_ndktest_MainActivity_DEFAULT_KEYS_SEARCH_LOCAL 3L\n#undef com_ndktest_MainActivity_DEFAULT_KEYS_SHORTCUT\n#define com_ndktest_MainActivity_DEFAULT_KEYS_SHORTCUT 2L\n#undef com_ndktest_MainActivity_RESULT_CANCELED\n#define com_ndktest_MainActivity_RESULT_CANCELED 0L\n#undef com_ndktest_MainActivity_RESULT_FIRST_USER\n#define com_ndktest_MainActivity_RESULT_FIRST_USER 1L\n#undef com_ndktest_MainActivity_RESULT_OK\n#define com_ndktest_MainActivity_RESULT_OK -1L\n/*\n * Class:     com_ndktest_MainActivity\n * Method:    getStringFromNative\n * Signature: ()Ljava/lang/String;\n */\nJNIEXPORT jstring JNICALL Java_com_ndktest_MainActivity_getStringFromNative\n  (JNIEnv *, jobject);\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n在<code>jni</code>中新建一个<code>c</code>文件，将名字命名为：<code>main.c</code>,输入以下内容:\n\n```c\n//\n// Created by Administrator on 2015/8/18.\n//\n#include \"com_ndktest_MainActivity.h\"\n/*\n * Class:     com_ndktest_MainActivity\n * Method:    getStringFromNative\n * Signature: ()Ljava/lang/String;\n */\nJNIEXPORT jstring JNICALL Java_com_ndktest_MainActivity_getStringFromNative\n        (JNIEnv * env, jobject obj){\n    return (*env)->NewStringUTF(env,\"I'm comes from to Native Function!\");\n}\n```\n&emsp;&emsp;如果编译出错，请在jni文件夹中新建一个空的<code>.c</code>文件，比如<code>utils.c</code>。在此我没有碰到错误，所以没有添加空文件\n\n在app目录下的<code>build.gradle</code>中设置库文件名（生成的<code>so</code>文件名--但是我在项目中并未看到有<code>so</code>文件生成）;\n&emsp;&emsp;找到<code>defaultConfig</code>项，添加以下内容：\n\n```groovy\nndk{  \n    moduleName \"MyJni\"  //设置库(so)文件名称  \n} \n```\n\n加载<code>so</code>文件:\n\n```groovy\nstatic {  \n    System.loadLibrary(\"MyJni\");  \n}\n```\n\n配置布局文件和入口文件\n&emsp;&emsp;在此贴出布局的完整代码：\n\n```xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n                xmlns:tools=\"http://schemas.android.com/tools\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n                android:paddingRight=\"@dimen/activity_horizontal_margin\"\n                android:paddingTop=\"@dimen/activity_vertical_margin\"\n                android:paddingBottom=\"@dimen/activity_vertical_margin\"\n                tools:context=\".MainActivity\" >\n    <TextView\n        android:text=\"@string/hello_world\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/myJni\" />\n</RelativeLayout>\n```\n\nMainActivity的完整代码:\n\n```java\npackage com.ndktest;\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.widget.TextView;\npublic class MainActivity extends Activity {\n    private TextView tv=null;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        tv=(TextView)findViewById(R.id.myJni);\n        tv.setText(getStringFromNative());\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.menu_main, menu);\n        return true;\n    }\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n    public native String getStringFromNative();\n    static {\n        System.loadLibrary(\"MyJni\");\n    }\n}\n```\n\n## 运行结果\n\n&emsp;&emsp;编译运行可以看到从native方法传过来的值：\n\n<div style=\"text-align: center;\">![ndk](https://coding.net/u/ibrucekong/p/images/git/raw/master/ndk.png)</div>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Android","NDK"],"categories":["languages"]},{"title":"Git安装与配置","url":"/posts/3219987363/","content":"**史上最好用的代码托管工具：**\n\n说到代码托管工具，Git绝对是迄今最好用的，它不论项目大小都适用，而且每一个Git克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。如果让我给你一个建议，那就是能用Git就不要使用其他（不偏心，谁用谁知道）。\n\n<!--more-->\n\n## Git概念\n\nGit 是一款免费的、开源的、分布式的版本控制系统。旨在快速高效地处理无论规模大小的任何软件工程。每一个Git克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。\n\n## Git的优势\n\n- 版本库本地化，支持离线提交，相对独立不影响协同开发；\n- 更少的“仓库污染”；\n- 把内容按元数据方式存储，完整克隆版本库；\n- 支持快速切换分支方便合并，比较合并性能好；\n- 布式版本库，无单点故障，内容完整性好。\n\n## Git安装与配置\n\n这里默认你已经有了Github账户，如果没有的话，点击[注册](https://github.com/join?source=header-home)去获取一个即可。这里以Windows演示一下Git的安装与配置：\n\n- 下载Git，进入[官网](https://git-scm.com/)，下载对应平台版本的安装包；\n- 安装Git并配置环境变量；\n  安装Git时会自动将Git配置到环境变量的PATH中，打开Git Bash输入git测试一下，是否安装成功；\n- 打开Git Bash配置用户变量\n```\ngit config --global user.name \"你的GitHub用户名\"\ngit config --global user.email \"你的GitHub注册邮箱\"\n```\n- 生成SSH Key并将公钥放置到Github上；\n在Git Bash中输入以下内容，一路回车即可；\n`ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"`\n打开`C:\\Users\\Administrator\\.ssh`目录，用记事本打开`id_rsa.pub`文件，打开[SSH and GPG Keys](https://github.com/settings/keys)新建一个SSH Key，将记事本中的内容复制到Key对话框中，保存即可；\n- 测试SSH Key是否添加成功；\n回到系统，打开Git Bash，输入以下内容，回车：\n`ssh -T git@github.com`\n出现有 *You've successfully authenticated* 的字样，就表示已经添加成功。\n\n## Git最常用命令\n\n- git init\n- git add\n- git commit\n- git push\n- git pull\n- git clone\n\n下面就可以正常使用Github了，可以使用`git init`初始化一个仓库，使用`git add`方法添加文件到仓库，使用`git commit`提交文件到本地仓库，使用`git push`提交本地仓库到Git服务器上，使用`git pull`拉取Git服务器上的代码，使用`git clone`来克隆服务器上的代码，以及其他高级用法，待后续... hava a good time！","tags":["git"],"categories":["languages"]},{"title":"Git安装与配置","url":"/posts/3219987363/","content":"**史上最好用的代码托管工具：**\n\n说到代码托管工具，Git绝对是迄今最好用的，它不论项目大小都适用，而且每一个Git克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。如果让我给你一个建议，那就是能用Git就不要使用其他（不偏心，谁用谁知道）。\n\n<!--more-->\n\n## Git概念\n\nGit 是一款免费的、开源的、分布式的版本控制系统。旨在快速高效地处理无论规模大小的任何软件工程。每一个Git克隆都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。\n\n## Git的优势\n\n- 版本库本地化，支持离线提交，相对独立不影响协同开发；\n- 更少的“仓库污染”；\n- 把内容按元数据方式存储，完整克隆版本库；\n- 支持快速切换分支方便合并，比较合并性能好；\n- 布式版本库，无单点故障，内容完整性好。\n\n## Git安装与配置\n\n这里默认你已经有了Github账户，如果没有的话，点击[注册](https://github.com/join?source=header-home)去获取一个即可。这里以Windows演示一下Git的安装与配置(以github为例，小伙伴要看准了哦)：\n\n- 下载Git，进入[官网](https://git-scm.com/)，下载对应平台版本的安装包；\n- 安装Git并配置环境变量；\n  安装Git时会自动将Git配置到环境变量的PATH中，打开Git Bash输入git测试一下，是否安装成功；\n- 打开Git Bash配置用户变量\n```\n// 每一行都是一条命令，其中$是命令行的意思，不需要输入$，另外每行的最后的参数也可以不加引号\n$ git config --global user.name \"你的GitHub用户名\"\n$ git config --global user.email \"你的GitHub注册邮箱\"\n```\n- 生成SSH Key并将公钥放置到Github上；\n在Git Bash中输入以下内容，一路回车即可；\n`ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"`\n打开`C:\\Users\\Administrator\\.ssh`目录，用记事本打开`id_rsa.pub`文件，打开[SSH and GPG Keys](https://github.com/settings/keys)新建一个SSH Key，将记事本中的内容复制到Key对话框中，保存即可；\n- 测试SSH Key是否添加成功；\n回到系统，打开Git Bash，输入以下内容，回车：\n`ssh -T git@github.com`\n出现有 *You've successfully authenticated* 的字样，就表示已经添加成功。\n\n***这里扩展一下，如果使用的是coding.net，则需要测试 `$ ssh -T git@git.coding.net` ，如果使用的是gitee.com或者git.oschina.com，则需要测试 `$ ssh -T git@gitee.com`或者`$ ssh -T git@git.oschina.net` ，不同的域名，给予的提示就不一样了 ***\n\n## Git最常用命令\n\n- git init\n- git add\n- git commit\n- git push\n- git pull\n- git clone\n- git status\n- git fetch\n- git stash\n- git stash pop\n- git branch\n- git checkout\n\n下面就可以正常使用Github了，可以使用`git init`初始化一个仓库，使用`git add`方法添加文件到仓库，使用`git commit`提交文件到本地仓库，使用`git push`提交本地仓库到Git服务器上，使用`git pull`拉取Git服务器上的代码，使用`git clone`来克隆服务器上的代码，以及其他高级用法，待后续... hava a good time！\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["git","版本管理"],"categories":["languages"]},{"title":"基于GIS的团队管理系统的简介","url":"/posts/4243991381/","content":"**基于地图的移动团队管理系统：**\n\n团队管理已经从传统的文字通讯，变成了基于地图的移动团队管理系统，让队员实时显示在地图上，系统使用期间还实时上传位置到服务器，便于管理者监督、管理、统计和分析。\n\n<!--more-->\n\n## 什么是TeamManager\n\n<div style=\"text-align: center;\">![team](https://coding.net/u/ibrucekong/p/images/git/raw/master/team.png)</div>\n\n<p>&emsp;&emsp;基于GIS的团队管理Android应用，本系统以Android为移动端平台，采用B/S架构进行Android客户端与服务器端开发，调用百度地图API进行地图开发，综合利用移动端定位技术和数据库技术、移动客户端与服务器端通信技术、WCF技术等实现了系统的各项功能。该系统主要实现的功能包括在实现传统团队管理的任务分发、日志记录、即时通讯的功能基础上，结合移动GIS技术实现对团队内部所有成员的准确实时追踪定位、轨迹回放、周边查询、紧急救援路线导航，同时团队管理员可以实现对内部成员的实时监控和轨迹回放等操作。</p>\n\n## 系统环境\n\n* Version : 1.0\n* Development platform : Android Studio 1.3\n* Gradle Version : 2.5\n* Gradle Plugin Version : 1.3.0\n\n## 功能介绍\n\n<h3 id=\"loginview\">登录界面</h3>\n\n*  包括头像，第一次登录时默认的是系统图标\n*  密码输入窗口\n*  忘记密码功能按钮\n*  注册功能按钮<br>\n\n<div style=\"text-align: center;\">![Login](https://coding.net/u/ibrucekong/p/images/git/raw/master/team-login.gif)</div>\n\n<h3 id=\"mapview\">地图界面</h3>\n\n*  显示当前位置信息\n*  切换显示的地图图层》普通地图 或 遥感图像\n*  是否记录运动轨迹\n*  放大和缩小\n*  查看缩放比例\n*  查找某地区的某位置<br><br>\n\n<div style=\"text-align: center;\">![Map](https://coding.net/u/ibrucekong/p/images/git/raw/master/team-map.gif)</div>\n\n<h3 id=\"teamview\">团队界面</h3>\n\n*  查找想要添加的团队\n*  创建团队\n*  管理员查看并管理团队信息，比如设置位置共享，解散团队（创建者）\n*  创建或查看公告\n*  创建或查看任务\n*  查看团队地图，可以查看到团队中启用位置共享的成员位置\n*  管理团队成员，比如：创建管理员\n*  团队聊天\n*  邀请好友加入当前团队\n*  管理员可以监控团队成员信息<br><br>\n\n<div style=\"text-align: center;\">![Team](https://coding.net/u/ibrucekong/p/images/git/raw/master/team-team.gif)</div>\n\n<h3 id=\"chatview\">通讯界面</h3>\n\n*  查找好友，查看或进行聊天\n*  聊天<br><br>\n\n<div style=\"text-align: center;\">![Chat](https://coding.net/u/ibrucekong/p/images/git/raw/master/team-chat.gif)</div>\n\n<h3 id=\"meview\">个人信息</h3>\n\n*  查看或修改个人信息\n*  签到，签出\n*  我的任务\n*  我的日志\n*  我的日程计划\n*  我的轨迹\n*  我的警示点\n*  我的兴趣点\n*  我的兴趣点热力图<br><br>\n\n<div style=\"text-align: center;\">![Me](https://coding.net/u/ibrucekong/p/images/git/raw/master/team-me.gif)</div>\n\n<h3 id=\"totalview\">整个录屏内容</h3>\n\n*  包含了上面全部的录制过程<br>\n\n<div style=\"text-align: center;\">![Total](https://coding.net/u/ibrucekong/p/images/git/raw/master/team-all.gif) </div>\n如果有不明白的，欢迎留言或者给我 <a href=mailto:kongbin0325@hotmail.com>发邮件[Send Email]</a>\n<div style=\"text-align: center;padding: 0; margin: 0;\">\n    <img class=\"wechat-qrcode\"  src=\"https://coding.net/u/ibrucekong/p/images/git/raw/master/wechat-blog.png\" alt=\"关注公众号\">\n</div>","tags":["Android","GIS"],"categories":["languages"]}]